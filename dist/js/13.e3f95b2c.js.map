{"version":3,"file":"js/13.e3f95b2c.js","mappings":"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","sources":["webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/lib/CustomRdfXmlParser.js","webpack://heat-rapid-triples/./node_modules/validate-iri/index.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/index.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/ParseError.js","webpack://heat-rapid-triples/./node_modules/xmlchars/xml/1.0/ed5.js","webpack://heat-rapid-triples/./node_modules/validate-iri/lib/Validate.js","webpack://heat-rapid-triples/./node_modules/@rubensworks/saxes/saxes.js","webpack://heat-rapid-triples/./node_modules/xmlchars/xmlns/1.0/ed3.js","webpack://heat-rapid-triples/./node_modules/xmlchars/xml/1.1/ed2.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/RdfXmlParser.js"],"sourcesContent":["import { RdfXmlParser } from 'rdfxml-streaming-parser';\nclass CustomRdfXmlParser extends RdfXmlParser {\n    constructor({ factory, ...args } = {}) {\n        super({ ...args, dataFactory: factory });\n    }\n}\nexport default CustomRdfXmlParser;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Validate\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/RdfXmlParser\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseError = void 0;\n/**\n * An error that includes line and column in the error message.\n */\nclass ParseError extends Error {\n    constructor(parser, message) {\n        const saxParser = parser.saxParser;\n        super(parser.trackPosition ? `Line ${saxParser.line} column ${saxParser.column + 1}: ${message}` : message);\n    }\n}\nexports.ParseError = ParseError;\n//# sourceMappingURL=ParseError.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 5th edition of XML 1.0.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= SPACE && c <= 0xD7FF) ||\n        c === NL || c === CR || c === TAB ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed5.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateIri = exports.IriValidationStrategy = void 0;\nfunction buildAbsoluteIriRfc3987Regex() {\n    // The syntax is defined in https://www.rfc-editor.org/rfc/rfc3987#section-2.2\n    // Rules are defined in reversed order\n    const sub_delims_raw = `!$&'()*+,;=`;\n    const sub_delims = `[${sub_delims_raw}]`;\n    const pct_encoded = `%[a-fA-F0-9]{2}`;\n    const dec_octet = '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n    const ipv4address = `${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}`;\n    const h16 = `[a-fA-F0-9]{1,4}`;\n    const ls32 = `(${h16}:${h16}|${ipv4address})`;\n    const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:){0,1}${h16})?::(${h16}:){3}${ls32}|((${h16}:){0,2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){0,3}${h16})?::${h16}:${ls32}|((${h16}:){0,4}${h16})?::${ls32}|((${h16}:){0,5}${h16})?::${h16}|((${h16}:){0,6}${h16})?::)`;\n    const ipvfuture = `v[a-fA-F0-9]+\\\\.(${sub_delims}|${sub_delims}|\":)+`;\n    const ip_literal = `\\\\[(${ipv6address}|${ipvfuture})\\\\]`;\n    const port = `[0-9]*`;\n    const scheme = `[a-zA-Z][a-zA-Z0-9+\\\\-.]*`;\n    const iprivate_raw = `\\u{E000}-\\u{F8FF}\\u{F0000}-\\u{FFFFD}\\u{100000}-\\u{10FFFD}`;\n    const iprivate = `[${iprivate_raw}]`;\n    const ucschar_raw = `\\u{A0}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFEF}\\u{10000}-\\u{1FFFD}\\u{20000}-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}\\u{50000}-\\u{5FFFD}\\u{60000}-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}\\u{90000}-\\u{9FFFD}\\u{A0000}-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}\\u{D0000}-\\u{DFFFD}\\u{E1000}-\\u{EFFFD}`;\n    const iunreserved_raw = `a-zA-Z0-9\\\\-._~${ucschar_raw}`;\n    const iunreserved = `[${iunreserved_raw}]`;\n    const ipchar = `(${iunreserved}|${pct_encoded}|${sub_delims}|[:@])*`;\n    const ifragment = `(${ipchar}|[\\\\/?])*`;\n    const iquery = `(${ipchar}|${iprivate}|[\\\\/?])*`;\n    const isegment_nz = `(${ipchar})+`;\n    const isegment = `(${ipchar})*`;\n    const ipath_empty = '';\n    const ipath_rootless = `${isegment_nz}(\\\\/${isegment})*`;\n    const ipath_absolute = `\\\\/(${isegment_nz}(\\\\/${isegment})*)?`;\n    const ipath_abempty = `(\\\\/${isegment})*`;\n    const ireg_name = `(${iunreserved}|${pct_encoded}|${sub_delims})*`;\n    const ihost = `(${ip_literal}|${ipv4address}|${ireg_name})`;\n    const iuserinfo = `(${iunreserved}|${pct_encoded}|${sub_delims}|:)*`;\n    const iauthority = `(${iuserinfo}@)?${ihost}(:${port})?`;\n    const ihier_part = `(\\\\/\\\\/${iauthority}${ipath_abempty}|${ipath_absolute}|${ipath_rootless}|${ipath_empty})`;\n    const iri = `^${scheme}:${ihier_part}(\\\\?${iquery})?(#${ifragment})?$`;\n    return new RegExp(iri, 'u');\n}\nconst STRICT_IRI_REGEX = buildAbsoluteIriRfc3987Regex();\n// eslint-disable-next-line no-control-regex\nconst PRAGMATIC_IRI_REGEX = /^[A-Za-z][\\d+-.A-Za-z]*:[^\\u0000-\\u0020\"<>\\\\^`{|}]*$/u;\n/**\n * Possible ways of validating an IRI\n */\nvar IriValidationStrategy;\n(function (IriValidationStrategy) {\n    /**\n     * Validates the IRI according to RFC 3987.\n     */\n    IriValidationStrategy[\"Strict\"] = \"strict\";\n    /**\n     * Validates that the IRI has a valid scheme and does not contain any character forbidden by the Turtle specification.\n     */\n    IriValidationStrategy[\"Pragmatic\"] = \"pragmatic\";\n    /**\n     * Does not validate the IRI at all.\n     */\n    IriValidationStrategy[\"None\"] = \"none\";\n})(IriValidationStrategy = exports.IriValidationStrategy || (exports.IriValidationStrategy = {}));\n/**\n * Validate a given IRI according to the given strategy.\n *\n * By default the IRI is fully validated according to RFC 3987.\n * But it is possible to do a lighter a faster validation using the \"pragmatic\" strategy.\n *\n * @param {string} iri a string that may be an IRI.\n * @param {IriValidationStrategy} strategy IRI validation strategy.\n * @return {Error | undefined} An error if the IRI is invalid, or undefined if it is valid.\n */\nfunction validateIri(iri, strategy = IriValidationStrategy.Strict) {\n    switch (strategy) {\n        case IriValidationStrategy.Strict:\n            return STRICT_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RFC 3987: '${iri}'`);\n        case IriValidationStrategy.Pragmatic:\n            return PRAGMATIC_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RDF Turtle: '${iri}'`);\n        case IriValidationStrategy.None:\n            return undefined;\n        default:\n            return new Error(`Not supported validation strategy \"${strategy}\"`);\n    }\n}\nexports.validateIri = validateIri;\n//# sourceMappingURL=Validate.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SaxesParser = exports.EVENTS = void 0;\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nclass SaxesParser {\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n            /* eslint-enable @typescript-eslint/unbound-method */\n        ];\n        this._init();\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    // We do need object for the type here. Yes, it often causes problems\n    // but not in this case.\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map","\"use strict\";\n/**\n * Character class utilities for XML NS 1.0 edition 3.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\n// tslint:disable-next-line:max-line-length\nexports.NC_NAME_START_CHAR = \"A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NC_NAME_CHAR = \"-\" + exports.NC_NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.NC_NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"]$\", \"u\");\nexports.NC_NAME_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_CHAR + \"]$\", \"u\");\nexports.NC_NAME_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"][\" + exports.NC_NAME_CHAR + \"]*$\", \"u\");\n/**\n * Determines whether a codepoint matches [[NC_NAME_START_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNCNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        c === 0x5F ||\n        (c >= 0x61 && c <= 0x7A) ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x200C && c <= 0x200D) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNCNameStartChar = isNCNameStartChar;\n/**\n * Determines whether a codepoint matches [[NC_NAME_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\nfunction isNCNameChar(c) {\n    return isNCNameStartChar(c) ||\n        (c === 0x2D ||\n            c === 0x2E ||\n            (c >= 0x30 && c <= 0x39) ||\n            c === 0x00B7 ||\n            (c >= 0x0300 && c <= 0x036F) ||\n            (c >= 0x203F && c <= 0x2040));\n}\nexports.isNCNameChar = isNCNameChar;\n//# sourceMappingURL=ed3.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 2nd edition of XML 1.1.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\u0001-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.RESTRICTED_CHAR = \"\\u0001-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F-\\u0084\\u0086-\\u009F\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.RESTRICTED_CHAR_RE = new RegExp(\"^[\" + exports.RESTRICTED_CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= 0x0001 && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``RESTRICTED_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``RESTRICTED_CHAR``.\n */\nfunction isRestrictedChar(c) {\n    return (c >= 0x1 && c <= 0x8) ||\n        c === 0xB ||\n        c === 0xC ||\n        (c >= 0xE && c <= 0x1F) ||\n        (c >= 0x7F && c <= 0x84) ||\n        (c >= 0x86 && c <= 0x9F);\n}\nexports.isRestrictedChar = isRestrictedChar;\n/**\n * Determines whether a codepoint matches the ``CHAR`` production and does not\n * match the ``RESTRICTED_CHAR`` production. ``isCharAndNotRestricted(x)`` is\n * equivalent to ``isChar(x) && !isRestrictedChar(x)``. This function is faster\n * than running the two-call equivalent.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR`` and does not match\n * ``RESTRICTED_CHAR``.\n */\nfunction isCharAndNotRestricted(c) {\n    return (c === 0x9) ||\n        (c === 0xA) ||\n        (c === 0xD) ||\n        (c > 0x1F && c < 0x7F) ||\n        (c === 0x85) ||\n        (c > 0x9F && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isCharAndNotRestricted = isCharAndNotRestricted;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseType = exports.RdfXmlParser = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst saxes_1 = require(\"@rubensworks/saxes\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst ParseError_1 = require(\"./ParseError\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst validate_iri_1 = require(\"validate-iri\");\nclass RdfXmlParser extends readable_stream_1.Transform {\n    constructor(args) {\n        super({ readableObjectMode: true });\n        this.activeTagStack = [];\n        this.nodeIds = {};\n        if (args) {\n            Object.assign(this, args);\n            this.options = args;\n        }\n        if (!this.dataFactory) {\n            this.dataFactory = new rdf_data_factory_1.DataFactory();\n        }\n        if (!this.baseIRI) {\n            this.baseIRI = '';\n        }\n        if (!this.defaultGraph) {\n            this.defaultGraph = this.dataFactory.defaultGraph();\n        }\n        if (this.validateUri !== false) {\n            this.validateUri = true;\n        }\n        if (!this.iriValidationStrategy) {\n            this.iriValidationStrategy = this.validateUri ? validate_iri_1.IriValidationStrategy.Pragmatic : validate_iri_1.IriValidationStrategy.None;\n        }\n        this.parseUnsupportedVersions = !!(args === null || args === void 0 ? void 0 : args.parseUnsupportedVersions);\n        this.version = args === null || args === void 0 ? void 0 : args.version;\n        this.saxParser = new saxes_1.SaxesParser({ xmlns: true, position: this.trackPosition });\n        this.attachSaxListeners();\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new readable_stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new RdfXmlParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.version) {\n            const version = this.version;\n            this.version = undefined;\n            if (!this.isValidVersion(version)) {\n                return callback(this.newParseError(`Detected unsupported version as media type parameter: ${version}`));\n            }\n        }\n        try {\n            this.saxParser.write(chunk);\n        }\n        catch (e) {\n            return callback(e);\n        }\n        callback();\n    }\n    /**\n     * Create a new parse error instance.\n     * @param {string} message An error message.\n     * @return {Error} An error instance.\n     */\n    newParseError(message) {\n        return new ParseError_1.ParseError(this, message);\n    }\n    /**\n     * Convert the given value to a IRI by taking into account the baseIRI.\n     *\n     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.\n     *\n     * @param {string} value The value to convert to an IRI.\n     * @param {IActiveTag} activeTag The active tag.\n     * @return {NamedNode} an IRI.\n     */\n    valueToUri(value, activeTag) {\n        return this.uriToNamedNode((0, relative_to_absolute_iri_1.resolve)(value, activeTag.baseIRI));\n    }\n    /**\n     * Convert the given value URI string to a named node.\n     *\n     * This throw an error if the URI is invalid.\n     *\n     * @param {string} uri A URI string.\n     * @return {NamedNode} a named node.\n     */\n    uriToNamedNode(uri) {\n        // Validate URI\n        const uriValidationResult = (0, validate_iri_1.validateIri)(uri, this.iriValidationStrategy);\n        if (uriValidationResult instanceof Error) {\n            throw this.newParseError(uriValidationResult.message);\n        }\n        return this.dataFactory.namedNode(uri);\n    }\n    /**\n     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n     * If it is invalid, an error will thrown emitted.\n     * @param {string} value A value.\n     */\n    validateNcname(value) {\n        // Validate term as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n        if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {\n            throw this.newParseError(`Not a valid NCName: ${value}`);\n        }\n    }\n    /**\n     * Create a new literal term.\n     * @param value The literal value.\n     * @param activeTag The active tag.\n     */\n    createLiteral(value, activeTag) {\n        return this.dataFactory.literal(value, activeTag.datatype ? activeTag.datatype : activeTag.language ? { language: activeTag.language, direction: activeTag.rdfVersion ? activeTag.direction : undefined } : undefined);\n    }\n    /**\n     * If the given version is valid for this parser to handle.\n     * @param version A version string.\n     */\n    isValidVersion(version) {\n        return this.parseUnsupportedVersions || RdfXmlParser.SUPPORTED_VERSIONS.includes(version);\n    }\n    attachSaxListeners() {\n        this.saxParser.on('error', (error) => this.emit('error', error));\n        this.saxParser.on('opentag', this.onTag.bind(this));\n        this.saxParser.on('text', this.onText.bind(this));\n        this.saxParser.on('cdata', this.onText.bind(this));\n        this.saxParser.on('closetag', this.onCloseTag.bind(this));\n        this.saxParser.on('doctype', this.onDoctype.bind(this));\n    }\n    /**\n     * Handle the given tag.\n     * @param {SaxesTagNS} tag A SAX tag.\n     */\n    onTag(tag) {\n        // Get parent tag\n        const parentTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        let currentParseType = ParseType.RESOURCE;\n        if (parentTag) {\n            parentTag.hadChildren = true;\n            currentParseType = parentTag.childrenParseType;\n        }\n        // Check if this tag needs to be converted to a string\n        if (parentTag && parentTag.childrenStringTags) {\n            // Convert this tag to a string\n            const tagName = tag.name;\n            let attributes = '';\n            for (const { key, value } of parentTag.namespaces || []) {\n                attributes += ` ${key}=\"${value}\"`;\n            }\n            for (const attributeKey in tag.attributes) {\n                attributes += ` ${attributeKey}=\"${tag.attributes[attributeKey].value}\"`;\n            }\n            const tagContents = `${tagName}${attributes}`;\n            const tagString = `<${tagContents}>`;\n            parentTag.childrenStringTags.push(tagString);\n            // Inherit the array, so that deeper tags are appended to this same array\n            const stringActiveTag = { childrenStringTags: parentTag.childrenStringTags };\n            stringActiveTag.childrenStringEmitClosingTag = `</${tagName}>`;\n            this.activeTagStack.push(stringActiveTag);\n            // Halt any further processing\n            return;\n        }\n        const activeTag = {};\n        if (parentTag) {\n            // Inherit properties from parent\n            activeTag.language = parentTag.language;\n            activeTag.direction = parentTag.direction;\n            activeTag.baseIRI = parentTag.baseIRI;\n            activeTag.childrenTripleTerms = parentTag.childrenTripleTerms;\n            activeTag.rdfVersion = parentTag.rdfVersion;\n        }\n        else {\n            activeTag.baseIRI = this.baseIRI;\n        }\n        this.activeTagStack.push(activeTag);\n        if (currentParseType === ParseType.RESOURCE) {\n            this.onTagResource(tag, activeTag, parentTag, !parentTag);\n        }\n        else { // currentParseType === ParseType.PROPERTY\n            this.onTagProperty(tag, activeTag, parentTag);\n        }\n        for (const attributeKey in tag.attributes) {\n            const attribute = tag.attributes[attributeKey];\n            if (attribute.prefix === 'xmlns') {\n                if (!activeTag.namespaces) {\n                    activeTag.namespaces = [];\n                }\n                activeTag.namespaces.push({ key: `${attribute.prefix}:${attribute.local}`, value: attribute.value });\n            }\n        }\n        if (parentTag && parentTag.namespaces) {\n            activeTag.namespaces = [...activeTag.namespaces || [], ...parentTag.namespaces];\n        }\n    }\n    /**\n     * Handle the given node element in resource-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     * @param {boolean} rootTag If we are currently processing the root tag.\n     */\n    onTagResource(tag, activeTag, parentTag, rootTag) {\n        activeTag.childrenParseType = ParseType.PROPERTY;\n        // Assume that the current node is a _typed_ node (2.13), unless we find an rdf:Description as node name\n        let typedNode = true;\n        if (tag.uri === RdfXmlParser.RDF) {\n            // Check forbidden property element names\n            if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tag.local) >= 0) {\n                throw this.newParseError(`Illegal node element name: ${tag.local}`);\n            }\n            switch (tag.local) {\n                case 'RDF':\n                    // Tags under <rdf:RDF> must always be resources\n                    activeTag.childrenParseType = ParseType.RESOURCE;\n                case 'Description':\n                    typedNode = false;\n            }\n        }\n        const predicates = [];\n        const objects = [];\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubjectValue = null;\n        let claimSubjectNodeId = false;\n        let subjectValueBlank = false;\n        let explicitType = null;\n        for (const attributeKey in tag.attributes) {\n            const attribute = tag.attributes[attributeKey];\n            if (attribute.uri === RdfXmlParser.RDF && attribute.local === 'version') {\n                this.setVersion(activeTag, attribute.value);\n                continue;\n            }\n            else if (parentTag && attribute.uri === RdfXmlParser.RDF) {\n                switch (attribute.local) {\n                    case 'about':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        activeSubjectValue = attribute.value;\n                        continue;\n                    case 'ID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = '#' + attribute.value;\n                        claimSubjectNodeId = true;\n                        continue;\n                    case 'nodeID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = attribute.value;\n                        subjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'type':\n                        // Emit the rdf:type later as named node instead of the default literal\n                        explicitType = attribute.value;\n                        continue;\n                    case 'aboutEach':\n                        throw this.newParseError(`rdf:aboutEach is not supported.`);\n                    case 'aboutEachPrefix':\n                        throw this.newParseError(`rdf:aboutEachPrefix is not supported.`);\n                    case 'li':\n                        throw this.newParseError(`rdf:li on node elements are not supported.`);\n                }\n            }\n            else if (attribute.uri === RdfXmlParser.XML) {\n                if (attribute.local === 'lang') {\n                    activeTag.language = attribute.value === '' ? null : attribute.value.toLowerCase();\n                    continue;\n                }\n                else if (attribute.local === 'base') {\n                    // SAX Parser does not expand xml:base, based on DOCTYPE, so we have to do it manually\n                    activeTag.baseIRI = (0, relative_to_absolute_iri_1.resolve)(attribute.value, activeTag.baseIRI);\n                    continue;\n                }\n            }\n            else if (attribute.uri === RdfXmlParser.ITS && attribute.local === 'dir') {\n                this.setDirection(activeTag, attribute.value);\n                continue;\n            }\n            // Interpret attributes at this point as properties on this node,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (attribute.prefix !== 'xml' && attribute.prefix !== 'xmlns'\n                && (attribute.prefix !== '' || attribute.local !== 'xmlns')\n                && attribute.uri) {\n                predicates.push(this.uriToNamedNode(attribute.uri + attribute.local));\n                objects.push(attribute.value);\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubjectValue !== null) {\n            activeTag.subject = subjectValueBlank\n                ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);\n            if (claimSubjectNodeId) {\n                this.claimNodeId(activeTag.subject);\n            }\n        }\n        // Force the creation of a subject if it doesn't exist yet\n        if (!activeTag.subject) {\n            activeTag.subject = this.dataFactory.blankNode();\n        }\n        // Emit the type if we're at a typed node\n        if (typedNode) {\n            const type = this.uriToNamedNode(tag.uri + tag.local);\n            this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), type, parentTag ? parentTag.reifiedStatementId : null, activeTag.childrenTripleTerms, activeTag.reifier);\n        }\n        if (parentTag) {\n            // If the parent tag defined a predicate, add the current tag as property value\n            if (parentTag.predicate) {\n                if (parentTag.childrenCollectionSubject) {\n                    // RDF:List-based properties\n                    const linkTerm = this.dataFactory.blankNode();\n                    const restTerm = this.dataFactory.namedNode(RdfXmlParser.RDF + 'rest');\n                    // Emit <x> <p> <current-chain> OR <previous-chain> <rdf:rest> <current-chain>\n                    const isRestTerm = parentTag.childrenCollectionPredicate.equals(restTerm);\n                    this.emitTriple(parentTag.childrenCollectionSubject, parentTag.childrenCollectionPredicate, linkTerm, isRestTerm ? null : parentTag.reifiedStatementId, parentTag.childrenTripleTerms, isRestTerm ? null : parentTag.reifier);\n                    // Emit <current-chain> <rdf:first> value\n                    this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + 'first'), activeTag.subject, null, activeTag.childrenTripleTerms);\n                    // Store <current-chain> in the parent node\n                    parentTag.childrenCollectionSubject = linkTerm;\n                    parentTag.childrenCollectionPredicate = restTerm;\n                }\n                else { // !parentTag.predicateEmitted\n                    // Set-based properties\n                    if (!parentTag.childrenTagsToTripleTerms) {\n                        this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId, parentTag.childrenTripleTerms, parentTag.reifier);\n                        parentTag.predicateEmitted = true;\n                    }\n                    // Emit pending properties on the parent tag that had no defined subject yet.\n                    for (let i = 0; i < parentTag.predicateSubPredicates.length; i++) {\n                        this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i], parentTag.predicateSubObjects[i], null, parentTag.childrenTripleTerms, parentTag.reifier);\n                    }\n                    // Cleanup so we don't emit them again when the parent tag is closed\n                    parentTag.predicateSubPredicates = [];\n                    parentTag.predicateSubObjects = [];\n                }\n            }\n            // Emit all collected triples\n            for (let i = 0; i < predicates.length; i++) {\n                const object = this.createLiteral(objects[i], activeTag);\n                this.emitTriple(activeTag.subject, predicates[i], object, parentTag.reifiedStatementId, parentTag.childrenTripleTerms, parentTag.reifier);\n            }\n            // Emit the rdf:type as named node instead of literal\n            if (explicitType) {\n                this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.uriToNamedNode(explicitType), null, activeTag.childrenTripleTerms, activeTag.reifier);\n            }\n        }\n    }\n    /**\n     * Handle the given property element in property-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     */\n    onTagProperty(tag, activeTag, parentTag) {\n        activeTag.childrenParseType = ParseType.RESOURCE;\n        activeTag.subject = parentTag.subject; // Inherit parent subject\n        if (tag.uri === RdfXmlParser.RDF && tag.local === 'li') {\n            // Convert rdf:li to rdf:_x\n            if (!parentTag.listItemCounter) {\n                parentTag.listItemCounter = 1;\n            }\n            activeTag.predicate = this.uriToNamedNode(tag.uri + '_' + parentTag.listItemCounter++);\n        }\n        else {\n            activeTag.predicate = this.uriToNamedNode(tag.uri + tag.local);\n        }\n        // Check forbidden property element names\n        if (tag.uri === RdfXmlParser.RDF\n            && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tag.local) >= 0) {\n            throw this.newParseError(`Illegal property element name: ${tag.local}`);\n        }\n        activeTag.predicateSubPredicates = [];\n        activeTag.predicateSubObjects = [];\n        let parseType = false;\n        let attributedProperty = false;\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubSubjectValue = null;\n        let subSubjectValueBlank = true;\n        const predicates = [];\n        const objects = [];\n        for (const propertyAttributeKey in tag.attributes) {\n            const propertyAttribute = tag.attributes[propertyAttributeKey];\n            if (propertyAttribute.uri === RdfXmlParser.RDF && propertyAttribute.local === 'version') {\n                this.setVersion(activeTag, propertyAttribute.value);\n                continue;\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.RDF) {\n                switch (propertyAttribute.local) {\n                    case 'resource':\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`Found both rdf:resource (${propertyAttribute.value}) and rdf:nodeID (${activeSubSubjectValue}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${propertyAttribute.value})`);\n                        }\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = false;\n                        continue;\n                    case 'datatype':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${propertyAttribute.value})`);\n                        }\n                        activeTag.datatype = this.valueToUri(propertyAttribute.value, activeTag);\n                        continue;\n                    case 'nodeID':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (activeTag.hadChildren) {\n                            throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${propertyAttribute.value})`);\n                        }\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'parseType':\n                        // Validation\n                        if (attributedProperty) {\n                            throw this.newParseError(`rdf:parseType is not allowed when non-rdf:* property attributes are present`);\n                        }\n                        if (activeTag.datatype) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${activeTag.datatype.value})`);\n                        }\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${activeSubSubjectValue})`);\n                        }\n                        if (propertyAttribute.value === 'Resource') {\n                            parseType = true;\n                            activeTag.childrenParseType = ParseType.PROPERTY;\n                            // Turn this property element into a node element\n                            const nestedBNode = this.dataFactory.blankNode();\n                            this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId, activeTag.childrenTripleTerms, activeTag.reifier);\n                            activeTag.subject = nestedBNode;\n                            activeTag.predicate = null;\n                        }\n                        else if (propertyAttribute.value === 'Collection') {\n                            parseType = true;\n                            // Interpret children as being part of an rdf:List\n                            activeTag.hadChildren = true;\n                            activeTag.childrenCollectionSubject = activeTag.subject;\n                            activeTag.childrenCollectionPredicate = activeTag.predicate;\n                            subSubjectValueBlank = false;\n                        }\n                        else if (propertyAttribute.value === 'Literal') {\n                            parseType = true;\n                            // Interpret children as being part of a literal string\n                            activeTag.childrenTagsToString = true;\n                            activeTag.childrenStringTags = [];\n                        }\n                        else if (propertyAttribute.value === 'Triple') {\n                            parseType = true;\n                            // Collect children as triple terms\n                            activeTag.childrenTagsToTripleTerms = true;\n                            activeTag.childrenTripleTerms = [];\n                        }\n                        continue;\n                    case 'ID':\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.reifiedStatementId = this.valueToUri('#' + propertyAttribute.value, activeTag);\n                        this.claimNodeId(activeTag.reifiedStatementId);\n                        continue;\n                    case 'annotation':\n                        activeTag.reifier = this.dataFactory.namedNode(propertyAttribute.value);\n                        continue;\n                    case 'annotationNodeID':\n                        activeTag.reifier = this.dataFactory.blankNode(propertyAttribute.value);\n                        continue;\n                }\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.XML && propertyAttribute.local === 'lang') {\n                activeTag.language = propertyAttribute.value === ''\n                    ? null : propertyAttribute.value.toLowerCase();\n                continue;\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.ITS && propertyAttribute.local === 'dir') {\n                this.setDirection(activeTag, propertyAttribute.value);\n                continue;\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.ITS && propertyAttribute.local === 'version') {\n                // Ignore its:version\n                continue;\n            }\n            // Interpret attributes at this point as properties via implicit blank nodes on the property,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (propertyAttribute.prefix !== 'xml' && propertyAttribute.prefix !== 'xmlns'\n                && (propertyAttribute.prefix !== '' || propertyAttribute.local !== 'xmlns')\n                && propertyAttribute.uri) {\n                if (parseType || activeTag.datatype) {\n                    throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${propertyAttribute.value}`);\n                }\n                activeTag.hadChildren = true;\n                attributedProperty = true;\n                predicates.push(this.uriToNamedNode(propertyAttribute.uri + propertyAttribute.local));\n                objects.push(this.createLiteral(propertyAttribute.value, activeTag));\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubSubjectValue !== null) {\n            const subjectParent = activeTag.subject;\n            activeTag.subject = subSubjectValueBlank\n                ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);\n            this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId, activeTag.childrenTripleTerms, activeTag.reifier);\n            // Emit our buffered triples\n            for (let i = 0; i < predicates.length; i++) {\n                this.emitTriple(activeTag.subject, predicates[i], objects[i], null, activeTag.childrenTripleTerms, activeTag.reifier);\n            }\n            activeTag.predicateEmitted = true;\n        }\n        else if (subSubjectValueBlank) {\n            // The current property element has no defined subject\n            // Let's buffer the properties until the child node defines a subject,\n            // or if the tag closes.\n            activeTag.predicateSubPredicates = predicates;\n            activeTag.predicateSubObjects = objects;\n            activeTag.predicateEmitted = false;\n        }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Term} subject A subject term.\n     * @param {Term} predicate A predicate term.\n     * @param {Term} object An object term.\n     * @param {Term} statementId An optional resource that identifies the triple.\n     *                           If truthy, then the given triple will also be emitted reified.\n     * @param childrenTripleTerms An optional array to push quads into instead of emitting them.\n     * @param reifier The reifier to emit this triple under.\n     */\n    emitTriple(subject, predicate, object, statementId, childrenTripleTerms, reifier) {\n        const quad = this.dataFactory.quad(subject, predicate, object, this.defaultGraph);\n        if (childrenTripleTerms) {\n            childrenTripleTerms.push(quad);\n        }\n        else {\n            this.push(quad);\n        }\n        if (reifier) {\n            this.push(this.dataFactory.quad(reifier, this.dataFactory.namedNode(RdfXmlParser.RDF + 'reifies'), quad));\n        }\n        // Reify triple\n        if (statementId) {\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.dataFactory.namedNode(RdfXmlParser.RDF + 'Statement'), this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'subject'), subject, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'predicate'), predicate, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'object'), object, this.defaultGraph));\n        }\n    }\n    /**\n     * Register the given term as a node ID.\n     * If one was already registered, this will emit an error.\n     *\n     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.\n     * @param {Term} term An RDF term.\n     */\n    claimNodeId(term) {\n        if (!this.allowDuplicateRdfIds) {\n            if (this.nodeIds[term.value]) {\n                throw this.newParseError(`Found multiple occurrences of rdf:ID='${term.value}'.`);\n            }\n            this.nodeIds[term.value] = true;\n        }\n    }\n    /**\n     * Handle the given text string.\n     * @param {string} text A parsed text string.\n     */\n    onText(text) {\n        const activeTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        if (activeTag) {\n            if (activeTag.childrenStringTags) {\n                activeTag.childrenStringTags.push(text);\n            }\n            else if (activeTag.predicate) {\n                activeTag.text = text;\n            }\n        }\n    }\n    /**\n     * Handle the closing of the last tag.\n     */\n    onCloseTag() {\n        const poppedTag = this.activeTagStack.pop();\n        const parentTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        // If we were converting a tag to a string, and the tag was not self-closing, close it here.\n        if (poppedTag.childrenStringEmitClosingTag) {\n            poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);\n        }\n        // Set the literal value if we were collecting XML tags to string\n        if (poppedTag.childrenTagsToString) {\n            poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + 'XMLLiteral');\n            poppedTag.text = poppedTag.childrenStringTags.join('');\n            poppedTag.hadChildren = false; // Force a literal triple to be emitted hereafter\n        }\n        // Set the triple term value if we were collecting triple terms\n        if (poppedTag.childrenTagsToTripleTerms && poppedTag.predicate && poppedTag.rdfVersion) {\n            if (poppedTag.childrenTripleTerms.length !== 1) {\n                throw this.newParseError(`Expected exactly one triple term in rdf:parseType=\"Triple\" but got ${poppedTag.childrenTripleTerms.length}`);\n            }\n            for (const tripleTerm of poppedTag.childrenTripleTerms) {\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, tripleTerm, null, parentTag.childrenTripleTerms, parentTag.reifier);\n            }\n            poppedTag.predicateEmitted = true;\n        }\n        if (poppedTag.childrenCollectionSubject) {\n            // Terminate the rdf:List\n            this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate, this.dataFactory.namedNode(RdfXmlParser.RDF + 'nil'), null, poppedTag.childrenTripleTerms);\n        }\n        else if (poppedTag.predicate) {\n            if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {\n                // Property element contains text\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, this.createLiteral(poppedTag.text || '', poppedTag), poppedTag.reifiedStatementId, poppedTag.childrenTripleTerms, poppedTag.reifier);\n            }\n            else if (!poppedTag.predicateEmitted) {\n                // Emit remaining properties on an anonymous property element\n                const subject = this.dataFactory.blankNode();\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId, poppedTag.childrenTripleTerms, poppedTag.reifier);\n                for (let i = 0; i < poppedTag.predicateSubPredicates.length; i++) {\n                    this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null, poppedTag.childrenTripleTerms);\n                }\n            }\n        }\n    }\n    /**\n     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.\n     * @param {string} doctype The read doctype.\n     */\n    onDoctype(doctype) {\n        doctype.replace(/<!ENTITY\\s+([^\\s]+)\\s+[\"']([^\"']+)[\"']\\s*>/g, (match, prefix, uri) => {\n            this.saxParser.ENTITIES[prefix] = uri;\n            return '';\n        });\n    }\n    setDirection(activeTag, value) {\n        if (value) {\n            if (value !== 'ltr' && value !== 'rtl') {\n                throw this.newParseError(`Base directions must either be 'ltr' or 'rtl', while '${value}' was found.`);\n            }\n            activeTag.direction = value;\n        }\n        else {\n            delete activeTag.direction;\n        }\n    }\n    setVersion(activeTag, version) {\n        activeTag.rdfVersion = version;\n        this.emit('version', version);\n        if (!this.isValidVersion(version)) {\n            throw this.newParseError(`Detected unsupported version: ${version}`);\n        }\n    }\n}\nexports.RdfXmlParser = RdfXmlParser;\nRdfXmlParser.MIME_TYPE = 'application/rdf+xml';\nRdfXmlParser.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nRdfXmlParser.XML = 'http://www.w3.org/XML/1998/namespace';\nRdfXmlParser.ITS = 'http://www.w3.org/2005/11/its';\nRdfXmlParser.FORBIDDEN_NODE_ELEMENTS = [\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'li',\n    'aboutEach',\n    'aboutEachPrefix',\n];\nRdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS = [\n    'Description',\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'aboutEach',\n    'aboutEachPrefix',\n];\n// tslint:disable-next-line:max-line-length\nRdfXmlParser.NCNAME_MATCHER = /^([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_])([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_\\-.0-9#xB7\\u{0300}-\\u{036F}\\u{203F}-\\u{2040}])*$/u;\nRdfXmlParser.SUPPORTED_VERSIONS = [\n    '1.2',\n    '1.2-basic',\n    '1.1',\n];\nvar ParseType;\n(function (ParseType) {\n    ParseType[ParseType[\"RESOURCE\"] = 0] = \"RESOURCE\";\n    ParseType[ParseType[\"PROPERTY\"] = 1] = \"PROPERTY\";\n})(ParseType || (exports.ParseType = ParseType = {}));\n//# sourceMappingURL=RdfXmlParser.js.map"],"names":["CustomRdfXmlParser","RdfXmlParser","constructor","factory","args","super","dataFactory","__createBinding","this","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","value","ParseError","Error","parser","message","saxParser","trackPosition","line","column","CHAR","S","NAME_START_CHAR","NAME_CHAR","CHAR_RE","RegExp","S_RE","NAME_START_CHAR_RE","NAME_CHAR_RE","NAME_RE","NMTOKEN_RE","TAB","NL","CR","SPACE","isChar","c","isS","isNameStartChar","isNameChar","S_LIST","buildAbsoluteIriRfc3987Regex","sub_delims_raw","sub_delims","pct_encoded","dec_octet","ipv4address","h16","ls32","ipv6address","ipvfuture","ip_literal","port","scheme","iprivate_raw","iprivate","ucschar_raw","iunreserved_raw","iunreserved","ipchar","ifragment","iquery","isegment_nz","isegment","ipath_empty","ipath_rootless","ipath_absolute","ipath_abempty","ireg_name","ihost","iuserinfo","iauthority","ihier_part","iri","validateIri","IriValidationStrategy","STRICT_IRI_REGEX","PRAGMATIC_IRI_REGEX","strategy","Strict","test","Pragmatic","None","SaxesParser","EVENTS","ed5","ed2","NSed3","isChar10","isChar11","isNCNameStartChar","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","EOC","NL_LIKE","S_BEGIN","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","S_XML_DECL_SEPARATOR","S_XML_DECL_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","NEL","LS","isQuote","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","prefix","uri","fail","nsMappingCheck","mapping","local","keys","isNCName","name","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","EVENT_NAME_TO_HANDLER_NAME","xmldecl","text","processinginstruction","doctype","comment","opentagstart","attribute","opentag","closetag","cdata","error","end","ready","closed","_closed","opt","fragmentOpt","fragment","xmlnsOpt","position","fileName","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","assign","additional","additionalNamespaces","processAttribsPlain","pushAttribPlain","stateTable","sBegin","sBeginWhitespace","sDoctype","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sText","sEntity","sOpenWaka","sOpenWakaBang","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","sPIEnding","sXMLDeclNameStart","sXMLDeclName","sXMLDeclEq","sXMLDeclValueStart","sXMLDeclValue","sXMLDeclSeparator","sXMLDeclEnding","sOpenTag","sOpenTagSlash","sAttrib","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","sCloseTagSawWhite","_init","_a","openWakaBang","piTarget","entity","q","tags","tag","topNS","chunk","chunkPosition","i","prevI","carriedFromPrevious","forbiddenState","attribList","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","xmlDeclExpects","entityReturnState","defaultXMLVersion","forceXMLVersion","setXMLVersion","positionAtNewLine","xmlDecl","version","encoding","standalone","ENTITIES","readyHandler","columnIndex","on","handler","off","makeError","msg","length","err","errorHandler","write","toString","limit","lastCode","charCodeAt","slice","close","getCode10","code","final","getCode11","next","getCodeNorm","getCode","unget","captureTo","chars","start","isNLLike","includes","captureToChar","char","captureNameChars","skipSpaces","currentXMLVersion","iBefore","doctypeHandler","String","fromCodePoint","owb","handleTextInRoot","handleTextOutsideRoot","loop","parsed","parseEntity","textHandler","commentHandler","cdataHandler","isQuestion","toLowerCase","piHandler","target","body","join","xmldeclHandler","attributes","openTagStartHandler","openTag","openSelfClosingTag","closeTag","scanLoop","nonSpace","outRootLoop","qname","attr","push","attributeHandler","trimmed","trim","_b","pop","endHandler","resolve","index","resolvePrefix","colon","indexOf","JSON","stringify","seen","Set","eqname","has","add","isSelfClosing","openTagHandler","_c","closeTagHandler","top","l","defined","num","NaN","parseInt","NC_NAME_START_CHAR","NC_NAME_CHAR","NC_NAME_START_CHAR_RE","NC_NAME_CHAR_RE","RESTRICTED_CHAR","RESTRICTED_CHAR_RE","isRestrictedChar","isCharAndNotRestricted","ParseType","relative_to_absolute_iri_1","saxes_1","readable_stream_1","ParseError_1","rdf_data_factory_1","validate_iri_1","Transform","readableObjectMode","activeTagStack","nodeIds","options","DataFactory","baseIRI","defaultGraph","validateUri","iriValidationStrategy","parseUnsupportedVersions","attachSaxListeners","import","stream","output","PassThrough","emit","data","pipe","_transform","callback","isValidVersion","newParseError","e","valueToUri","activeTag","uriToNamedNode","uriValidationResult","namedNode","validateNcname","NCNAME_MATCHER","createLiteral","literal","datatype","language","direction","rdfVersion","SUPPORTED_VERSIONS","onTag","bind","onText","onCloseTag","onDoctype","parentTag","currentParseType","RESOURCE","hadChildren","childrenParseType","childrenStringTags","tagName","key","namespaces","attributeKey","tagContents","tagString","stringActiveTag","childrenStringEmitClosingTag","childrenTripleTerms","onTagResource","onTagProperty","rootTag","PROPERTY","typedNode","RDF","FORBIDDEN_NODE_ELEMENTS","predicates","objects","activeSubjectValue","claimSubjectNodeId","subjectValueBlank","explicitType","XML","ITS","setDirection","setVersion","subject","blankNode","claimNodeId","type","emitTriple","reifiedStatementId","reifier","predicate","childrenCollectionSubject","linkTerm","restTerm","isRestTerm","childrenCollectionPredicate","equals","childrenTagsToTripleTerms","predicateEmitted","predicateSubPredicates","predicateSubObjects","object","listItemCounter","FORBIDDEN_PROPERTY_ELEMENTS","parseType","attributedProperty","activeSubSubjectValue","subSubjectValueBlank","propertyAttributeKey","propertyAttribute","nestedBNode","childrenTagsToString","subjectParent","statementId","quad","term","allowDuplicateRdfIds","poppedTag","tripleTerm","replace","match","MIME_TYPE"],"ignoreList":[],"sourceRoot":""}