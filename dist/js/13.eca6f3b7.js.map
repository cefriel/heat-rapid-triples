{"version":3,"file":"js/13.eca6f3b7.js","mappings":"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","sources":["webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/NamedNode.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/lib/CustomRdfXmlParser.js","webpack://heat-rapid-triples/./node_modules/validate-iri/index.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/DataFactory.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/index.js","webpack://heat-rapid-triples/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/ParseError.js","webpack://heat-rapid-triples/./node_modules/xmlchars/xml/1.0/ed5.js","webpack://heat-rapid-triples/./node_modules/validate-iri/lib/Validate.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/BlankNode.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/Quad.js","webpack://heat-rapid-triples/./node_modules/@rubensworks/saxes/saxes.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/index.js","webpack://heat-rapid-triples/./node_modules/xmlchars/xmlns/1.0/ed3.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/Literal.js","webpack://heat-rapid-triples/./node_modules/relative-to-absolute-iri/index.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/Variable.js","webpack://heat-rapid-triples/./node_modules/xmlchars/xml/1.1/ed2.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/RdfXmlParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","import { RdfXmlParser } from 'rdfxml-streaming-parser';\nclass CustomRdfXmlParser extends RdfXmlParser {\n    constructor({ factory, ...args } = {}) {\n        super({ ...args, dataFactory: factory });\n    }\n}\nexport default CustomRdfXmlParser;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Validate\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language, datatype, or directional language.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           If `languageOrDatatype` is a NamedNode, it is used for the value\n     *                           of `NamedNode.language`.\n     *                           Otherwise, it is used as a directional language,\n     *                           from which the language is set to `languageOrDatatype.language`\n     *                           and the direction to `languageOrDatatype.direction`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/RdfXmlParser\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseError = void 0;\n/**\n * An error that includes line and column in the error message.\n */\nclass ParseError extends Error {\n    constructor(parser, message) {\n        const saxParser = parser.saxParser;\n        super(parser.trackPosition ? `Line ${saxParser.line} column ${saxParser.column + 1}: ${message}` : message);\n    }\n}\nexports.ParseError = ParseError;\n//# sourceMappingURL=ParseError.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 5th edition of XML 1.0.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= SPACE && c <= 0xD7FF) ||\n        c === NL || c === CR || c === TAB ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed5.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateIri = exports.IriValidationStrategy = void 0;\nfunction buildAbsoluteIriRfc3987Regex() {\n    // The syntax is defined in https://www.rfc-editor.org/rfc/rfc3987#section-2.2\n    // Rules are defined in reversed order\n    const sub_delims_raw = `!$&'()*+,;=`;\n    const sub_delims = `[${sub_delims_raw}]`;\n    const pct_encoded = `%[a-fA-F0-9]{2}`;\n    const dec_octet = '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n    const ipv4address = `${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}`;\n    const h16 = `[a-fA-F0-9]{1,4}`;\n    const ls32 = `(${h16}:${h16}|${ipv4address})`;\n    const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:){0,1}${h16})?::(${h16}:){3}${ls32}|((${h16}:){0,2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){0,3}${h16})?::${h16}:${ls32}|((${h16}:){0,4}${h16})?::${ls32}|((${h16}:){0,5}${h16})?::${h16}|((${h16}:){0,6}${h16})?::)`;\n    const ipvfuture = `v[a-fA-F0-9]+\\\\.(${sub_delims}|${sub_delims}|\":)+`;\n    const ip_literal = `\\\\[(${ipv6address}|${ipvfuture})\\\\]`;\n    const port = `[0-9]*`;\n    const scheme = `[a-zA-Z][a-zA-Z0-9+\\\\-.]*`;\n    const iprivate_raw = `\\u{E000}-\\u{F8FF}\\u{F0000}-\\u{FFFFD}\\u{100000}-\\u{10FFFD}`;\n    const iprivate = `[${iprivate_raw}]`;\n    const ucschar_raw = `\\u{A0}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFEF}\\u{10000}-\\u{1FFFD}\\u{20000}-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}\\u{50000}-\\u{5FFFD}\\u{60000}-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}\\u{90000}-\\u{9FFFD}\\u{A0000}-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}\\u{D0000}-\\u{DFFFD}\\u{E1000}-\\u{EFFFD}`;\n    const iunreserved_raw = `a-zA-Z0-9\\\\-._~${ucschar_raw}`;\n    const iunreserved = `[${iunreserved_raw}]`;\n    const ipchar = `(${iunreserved}|${pct_encoded}|${sub_delims}|[:@])*`;\n    const ifragment = `(${ipchar}|[\\\\/?])*`;\n    const iquery = `(${ipchar}|${iprivate}|[\\\\/?])*`;\n    const isegment_nz = `(${ipchar})+`;\n    const isegment = `(${ipchar})*`;\n    const ipath_empty = '';\n    const ipath_rootless = `${isegment_nz}(\\\\/${isegment})*`;\n    const ipath_absolute = `\\\\/(${isegment_nz}(\\\\/${isegment})*)?`;\n    const ipath_abempty = `(\\\\/${isegment})*`;\n    const ireg_name = `(${iunreserved}|${pct_encoded}|${sub_delims})*`;\n    const ihost = `(${ip_literal}|${ipv4address}|${ireg_name})`;\n    const iuserinfo = `(${iunreserved}|${pct_encoded}|${sub_delims}|:)*`;\n    const iauthority = `(${iuserinfo}@)?${ihost}(:${port})?`;\n    const ihier_part = `(\\\\/\\\\/${iauthority}${ipath_abempty}|${ipath_absolute}|${ipath_rootless}|${ipath_empty})`;\n    const iri = `^${scheme}:${ihier_part}(\\\\?${iquery})?(#${ifragment})?$`;\n    return new RegExp(iri, 'u');\n}\nconst STRICT_IRI_REGEX = buildAbsoluteIriRfc3987Regex();\n// eslint-disable-next-line no-control-regex\nconst PRAGMATIC_IRI_REGEX = /^[A-Za-z][\\d+-.A-Za-z]*:[^\\u0000-\\u0020\"<>\\\\^`{|}]*$/u;\n/**\n * Possible ways of validating an IRI\n */\nvar IriValidationStrategy;\n(function (IriValidationStrategy) {\n    /**\n     * Validates the IRI according to RFC 3987.\n     */\n    IriValidationStrategy[\"Strict\"] = \"strict\";\n    /**\n     * Validates that the IRI has a valid scheme and does not contain any character forbidden by the Turtle specification.\n     */\n    IriValidationStrategy[\"Pragmatic\"] = \"pragmatic\";\n    /**\n     * Does not validate the IRI at all.\n     */\n    IriValidationStrategy[\"None\"] = \"none\";\n})(IriValidationStrategy = exports.IriValidationStrategy || (exports.IriValidationStrategy = {}));\n/**\n * Validate a given IRI according to the given strategy.\n *\n * By default the IRI is fully validated according to RFC 3987.\n * But it is possible to do a lighter a faster validation using the \"pragmatic\" strategy.\n *\n * @param {string} iri a string that may be an IRI.\n * @param {IriValidationStrategy} strategy IRI validation strategy.\n * @return {Error | undefined} An error if the IRI is invalid, or undefined if it is valid.\n */\nfunction validateIri(iri, strategy = IriValidationStrategy.Strict) {\n    switch (strategy) {\n        case IriValidationStrategy.Strict:\n            return STRICT_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RFC 3987: '${iri}'`);\n        case IriValidationStrategy.Pragmatic:\n            return PRAGMATIC_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RDF Turtle: '${iri}'`);\n        case IriValidationStrategy.None:\n            return undefined;\n        default:\n            return new Error(`Not supported validation strategy \"${strategy}\"`);\n    }\n}\nexports.validateIri = validateIri;\n//# sourceMappingURL=Validate.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SaxesParser = exports.EVENTS = void 0;\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nclass SaxesParser {\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n            /* eslint-enable @typescript-eslint/unbound-method */\n        ];\n        this._init();\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    // We do need object for the type here. Yes, it often causes problems\n    // but not in this case.\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * Character class utilities for XML NS 1.0 edition 3.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\n// tslint:disable-next-line:max-line-length\nexports.NC_NAME_START_CHAR = \"A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NC_NAME_CHAR = \"-\" + exports.NC_NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.NC_NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"]$\", \"u\");\nexports.NC_NAME_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_CHAR + \"]$\", \"u\");\nexports.NC_NAME_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"][\" + exports.NC_NAME_CHAR + \"]*$\", \"u\");\n/**\n * Determines whether a codepoint matches [[NC_NAME_START_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNCNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        c === 0x5F ||\n        (c >= 0x61 && c <= 0x7A) ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x200C && c <= 0x200D) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNCNameStartChar = isNCNameStartChar;\n/**\n * Determines whether a codepoint matches [[NC_NAME_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\nfunction isNCNameChar(c) {\n    return isNCNameStartChar(c) ||\n        (c === 0x2D ||\n            c === 0x2E ||\n            (c >= 0x30 && c <= 0x39) ||\n            c === 0x00B7 ||\n            (c >= 0x0300 && c <= 0x036F) ||\n            (c >= 0x203F && c <= 0x2040));\n}\nexports.isNCNameChar = isNCNameChar;\n//# sourceMappingURL=ed3.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal,\n * containing a string with an optional language tag and optional direction\n * or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n            this.direction = '';\n        }\n        else if (languageOrDatatype) {\n            if ('termType' in languageOrDatatype) {\n                this.language = '';\n                this.datatype = languageOrDatatype;\n                this.direction = '';\n            }\n            else {\n                this.language = languageOrDatatype.language;\n                this.datatype = languageOrDatatype.direction ?\n                    Literal.RDF_DIRECTIONAL_LANGUAGE_STRING :\n                    Literal.RDF_LANGUAGE_STRING;\n                this.direction = languageOrDatatype.direction || '';\n            }\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n            this.direction = '';\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language &&\n            ((other.direction === this.direction) || (!other.direction && this.direction === '')) &&\n            this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.RDF_DIRECTIONAL_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 2nd edition of XML 1.1.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\u0001-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.RESTRICTED_CHAR = \"\\u0001-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F-\\u0084\\u0086-\\u009F\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.RESTRICTED_CHAR_RE = new RegExp(\"^[\" + exports.RESTRICTED_CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= 0x0001 && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``RESTRICTED_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``RESTRICTED_CHAR``.\n */\nfunction isRestrictedChar(c) {\n    return (c >= 0x1 && c <= 0x8) ||\n        c === 0xB ||\n        c === 0xC ||\n        (c >= 0xE && c <= 0x1F) ||\n        (c >= 0x7F && c <= 0x84) ||\n        (c >= 0x86 && c <= 0x9F);\n}\nexports.isRestrictedChar = isRestrictedChar;\n/**\n * Determines whether a codepoint matches the ``CHAR`` production and does not\n * match the ``RESTRICTED_CHAR`` production. ``isCharAndNotRestricted(x)`` is\n * equivalent to ``isChar(x) && !isRestrictedChar(x)``. This function is faster\n * than running the two-call equivalent.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR`` and does not match\n * ``RESTRICTED_CHAR``.\n */\nfunction isCharAndNotRestricted(c) {\n    return (c === 0x9) ||\n        (c === 0xA) ||\n        (c === 0xD) ||\n        (c > 0x1F && c < 0x7F) ||\n        (c === 0x85) ||\n        (c > 0x9F && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isCharAndNotRestricted = isCharAndNotRestricted;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseType = exports.RdfXmlParser = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst saxes_1 = require(\"@rubensworks/saxes\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst ParseError_1 = require(\"./ParseError\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst validate_iri_1 = require(\"validate-iri\");\nclass RdfXmlParser extends readable_stream_1.Transform {\n    constructor(args) {\n        super({ readableObjectMode: true });\n        this.activeTagStack = [];\n        this.nodeIds = {};\n        if (args) {\n            Object.assign(this, args);\n            this.options = args;\n        }\n        if (!this.dataFactory) {\n            this.dataFactory = new rdf_data_factory_1.DataFactory();\n        }\n        if (!this.baseIRI) {\n            this.baseIRI = '';\n        }\n        if (!this.defaultGraph) {\n            this.defaultGraph = this.dataFactory.defaultGraph();\n        }\n        if (this.validateUri !== false) {\n            this.validateUri = true;\n        }\n        if (!this.iriValidationStrategy) {\n            this.iriValidationStrategy = this.validateUri ? validate_iri_1.IriValidationStrategy.Pragmatic : validate_iri_1.IriValidationStrategy.None;\n        }\n        this.parseUnsupportedVersions = !!(args === null || args === void 0 ? void 0 : args.parseUnsupportedVersions);\n        this.version = args === null || args === void 0 ? void 0 : args.version;\n        this.saxParser = new saxes_1.SaxesParser({ xmlns: true, position: this.trackPosition });\n        this.attachSaxListeners();\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new readable_stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new RdfXmlParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.version) {\n            const version = this.version;\n            this.version = undefined;\n            if (!this.isValidVersion(version)) {\n                return callback(this.newParseError(`Detected unsupported version as media type parameter: ${version}`));\n            }\n        }\n        try {\n            this.saxParser.write(chunk);\n        }\n        catch (e) {\n            return callback(e);\n        }\n        callback();\n    }\n    /**\n     * Create a new parse error instance.\n     * @param {string} message An error message.\n     * @return {Error} An error instance.\n     */\n    newParseError(message) {\n        return new ParseError_1.ParseError(this, message);\n    }\n    /**\n     * Convert the given value to a IRI by taking into account the baseIRI.\n     *\n     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.\n     *\n     * @param {string} value The value to convert to an IRI.\n     * @param {IActiveTag} activeTag The active tag.\n     * @return {NamedNode} an IRI.\n     */\n    valueToUri(value, activeTag) {\n        return this.uriToNamedNode((0, relative_to_absolute_iri_1.resolve)(value, activeTag.baseIRI));\n    }\n    /**\n     * Convert the given value URI string to a named node.\n     *\n     * This throw an error if the URI is invalid.\n     *\n     * @param {string} uri A URI string.\n     * @return {NamedNode} a named node.\n     */\n    uriToNamedNode(uri) {\n        // Validate URI\n        const uriValidationResult = (0, validate_iri_1.validateIri)(uri, this.iriValidationStrategy);\n        if (uriValidationResult instanceof Error) {\n            throw this.newParseError(uriValidationResult.message);\n        }\n        return this.dataFactory.namedNode(uri);\n    }\n    /**\n     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n     * If it is invalid, an error will thrown emitted.\n     * @param {string} value A value.\n     */\n    validateNcname(value) {\n        // Validate term as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n        if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {\n            throw this.newParseError(`Not a valid NCName: ${value}`);\n        }\n    }\n    /**\n     * Create a new literal term.\n     * @param value The literal value.\n     * @param activeTag The active tag.\n     */\n    createLiteral(value, activeTag) {\n        return this.dataFactory.literal(value, activeTag.datatype ? activeTag.datatype : activeTag.language ? { language: activeTag.language, direction: activeTag.rdfVersion ? activeTag.direction : undefined } : undefined);\n    }\n    /**\n     * If the given version is valid for this parser to handle.\n     * @param version A version string.\n     */\n    isValidVersion(version) {\n        return this.parseUnsupportedVersions || RdfXmlParser.SUPPORTED_VERSIONS.includes(version);\n    }\n    attachSaxListeners() {\n        this.saxParser.on('error', (error) => this.emit('error', error));\n        this.saxParser.on('opentag', this.onTag.bind(this));\n        this.saxParser.on('text', this.onText.bind(this));\n        this.saxParser.on('cdata', this.onText.bind(this));\n        this.saxParser.on('closetag', this.onCloseTag.bind(this));\n        this.saxParser.on('doctype', this.onDoctype.bind(this));\n    }\n    /**\n     * Handle the given tag.\n     * @param {SaxesTagNS} tag A SAX tag.\n     */\n    onTag(tag) {\n        // Get parent tag\n        const parentTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        let currentParseType = ParseType.RESOURCE;\n        if (parentTag) {\n            parentTag.hadChildren = true;\n            currentParseType = parentTag.childrenParseType;\n        }\n        // Check if this tag needs to be converted to a string\n        if (parentTag && parentTag.childrenStringTags) {\n            // Convert this tag to a string\n            const tagName = tag.name;\n            let attributes = '';\n            for (const { key, value } of parentTag.namespaces || []) {\n                attributes += ` ${key}=\"${value}\"`;\n            }\n            for (const attributeKey in tag.attributes) {\n                attributes += ` ${attributeKey}=\"${tag.attributes[attributeKey].value}\"`;\n            }\n            const tagContents = `${tagName}${attributes}`;\n            const tagString = `<${tagContents}>`;\n            parentTag.childrenStringTags.push(tagString);\n            // Inherit the array, so that deeper tags are appended to this same array\n            const stringActiveTag = { childrenStringTags: parentTag.childrenStringTags };\n            stringActiveTag.childrenStringEmitClosingTag = `</${tagName}>`;\n            this.activeTagStack.push(stringActiveTag);\n            // Halt any further processing\n            return;\n        }\n        const activeTag = {};\n        if (parentTag) {\n            // Inherit properties from parent\n            activeTag.language = parentTag.language;\n            activeTag.direction = parentTag.direction;\n            activeTag.baseIRI = parentTag.baseIRI;\n            activeTag.childrenTripleTerms = parentTag.childrenTripleTerms;\n            activeTag.rdfVersion = parentTag.rdfVersion;\n        }\n        else {\n            activeTag.baseIRI = this.baseIRI;\n        }\n        this.activeTagStack.push(activeTag);\n        if (currentParseType === ParseType.RESOURCE) {\n            this.onTagResource(tag, activeTag, parentTag, !parentTag);\n        }\n        else { // currentParseType === ParseType.PROPERTY\n            this.onTagProperty(tag, activeTag, parentTag);\n        }\n        for (const attributeKey in tag.attributes) {\n            const attribute = tag.attributes[attributeKey];\n            if (attribute.prefix === 'xmlns') {\n                if (!activeTag.namespaces) {\n                    activeTag.namespaces = [];\n                }\n                activeTag.namespaces.push({ key: `${attribute.prefix}:${attribute.local}`, value: attribute.value });\n            }\n        }\n        if (parentTag && parentTag.namespaces) {\n            activeTag.namespaces = [...activeTag.namespaces || [], ...parentTag.namespaces];\n        }\n    }\n    /**\n     * Handle the given node element in resource-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     * @param {boolean} rootTag If we are currently processing the root tag.\n     */\n    onTagResource(tag, activeTag, parentTag, rootTag) {\n        activeTag.childrenParseType = ParseType.PROPERTY;\n        // Assume that the current node is a _typed_ node (2.13), unless we find an rdf:Description as node name\n        let typedNode = true;\n        if (tag.uri === RdfXmlParser.RDF) {\n            // Check forbidden property element names\n            if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tag.local) >= 0) {\n                throw this.newParseError(`Illegal node element name: ${tag.local}`);\n            }\n            switch (tag.local) {\n                case 'RDF':\n                    // Tags under <rdf:RDF> must always be resources\n                    activeTag.childrenParseType = ParseType.RESOURCE;\n                case 'Description':\n                    typedNode = false;\n            }\n        }\n        const predicates = [];\n        const objects = [];\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubjectValue = null;\n        let claimSubjectNodeId = false;\n        let subjectValueBlank = false;\n        let explicitType = null;\n        for (const attributeKey in tag.attributes) {\n            const attribute = tag.attributes[attributeKey];\n            if (attribute.uri === RdfXmlParser.RDF && attribute.local === 'version') {\n                this.setVersion(activeTag, attribute.value);\n                continue;\n            }\n            else if (parentTag && attribute.uri === RdfXmlParser.RDF) {\n                switch (attribute.local) {\n                    case 'about':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        activeSubjectValue = attribute.value;\n                        continue;\n                    case 'ID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = '#' + attribute.value;\n                        claimSubjectNodeId = true;\n                        continue;\n                    case 'nodeID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = attribute.value;\n                        subjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'type':\n                        // Emit the rdf:type later as named node instead of the default literal\n                        explicitType = attribute.value;\n                        continue;\n                    case 'aboutEach':\n                        throw this.newParseError(`rdf:aboutEach is not supported.`);\n                    case 'aboutEachPrefix':\n                        throw this.newParseError(`rdf:aboutEachPrefix is not supported.`);\n                    case 'li':\n                        throw this.newParseError(`rdf:li on node elements are not supported.`);\n                }\n            }\n            else if (attribute.uri === RdfXmlParser.XML) {\n                if (attribute.local === 'lang') {\n                    activeTag.language = attribute.value === '' ? null : attribute.value.toLowerCase();\n                    continue;\n                }\n                else if (attribute.local === 'base') {\n                    // SAX Parser does not expand xml:base, based on DOCTYPE, so we have to do it manually\n                    activeTag.baseIRI = (0, relative_to_absolute_iri_1.resolve)(attribute.value, activeTag.baseIRI);\n                    continue;\n                }\n            }\n            else if (attribute.uri === RdfXmlParser.ITS && attribute.local === 'dir') {\n                this.setDirection(activeTag, attribute.value);\n                continue;\n            }\n            // Interpret attributes at this point as properties on this node,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (attribute.prefix !== 'xml' && attribute.prefix !== 'xmlns'\n                && (attribute.prefix !== '' || attribute.local !== 'xmlns')\n                && attribute.uri) {\n                predicates.push(this.uriToNamedNode(attribute.uri + attribute.local));\n                objects.push(attribute.value);\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubjectValue !== null) {\n            activeTag.subject = subjectValueBlank\n                ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);\n            if (claimSubjectNodeId) {\n                this.claimNodeId(activeTag.subject);\n            }\n        }\n        // Force the creation of a subject if it doesn't exist yet\n        if (!activeTag.subject) {\n            activeTag.subject = this.dataFactory.blankNode();\n        }\n        // Emit the type if we're at a typed node\n        if (typedNode) {\n            const type = this.uriToNamedNode(tag.uri + tag.local);\n            this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), type, parentTag ? parentTag.reifiedStatementId : null, activeTag.childrenTripleTerms, activeTag.reifier);\n        }\n        if (parentTag) {\n            // If the parent tag defined a predicate, add the current tag as property value\n            if (parentTag.predicate) {\n                if (parentTag.childrenCollectionSubject) {\n                    // RDF:List-based properties\n                    const linkTerm = this.dataFactory.blankNode();\n                    const restTerm = this.dataFactory.namedNode(RdfXmlParser.RDF + 'rest');\n                    // Emit <x> <p> <current-chain> OR <previous-chain> <rdf:rest> <current-chain>\n                    const isRestTerm = parentTag.childrenCollectionPredicate.equals(restTerm);\n                    this.emitTriple(parentTag.childrenCollectionSubject, parentTag.childrenCollectionPredicate, linkTerm, isRestTerm ? null : parentTag.reifiedStatementId, parentTag.childrenTripleTerms, isRestTerm ? null : parentTag.reifier);\n                    // Emit <current-chain> <rdf:first> value\n                    this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + 'first'), activeTag.subject, null, activeTag.childrenTripleTerms);\n                    // Store <current-chain> in the parent node\n                    parentTag.childrenCollectionSubject = linkTerm;\n                    parentTag.childrenCollectionPredicate = restTerm;\n                }\n                else { // !parentTag.predicateEmitted\n                    // Set-based properties\n                    if (!parentTag.childrenTagsToTripleTerms) {\n                        this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId, parentTag.childrenTripleTerms, parentTag.reifier);\n                        parentTag.predicateEmitted = true;\n                    }\n                    // Emit pending properties on the parent tag that had no defined subject yet.\n                    for (let i = 0; i < parentTag.predicateSubPredicates.length; i++) {\n                        this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i], parentTag.predicateSubObjects[i], null, parentTag.childrenTripleTerms, parentTag.reifier);\n                    }\n                    // Cleanup so we don't emit them again when the parent tag is closed\n                    parentTag.predicateSubPredicates = [];\n                    parentTag.predicateSubObjects = [];\n                }\n            }\n            // Emit all collected triples\n            for (let i = 0; i < predicates.length; i++) {\n                const object = this.createLiteral(objects[i], activeTag);\n                this.emitTriple(activeTag.subject, predicates[i], object, parentTag.reifiedStatementId, parentTag.childrenTripleTerms, parentTag.reifier);\n            }\n            // Emit the rdf:type as named node instead of literal\n            if (explicitType) {\n                this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.uriToNamedNode(explicitType), null, activeTag.childrenTripleTerms, activeTag.reifier);\n            }\n        }\n    }\n    /**\n     * Handle the given property element in property-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     */\n    onTagProperty(tag, activeTag, parentTag) {\n        activeTag.childrenParseType = ParseType.RESOURCE;\n        activeTag.subject = parentTag.subject; // Inherit parent subject\n        if (tag.uri === RdfXmlParser.RDF && tag.local === 'li') {\n            // Convert rdf:li to rdf:_x\n            if (!parentTag.listItemCounter) {\n                parentTag.listItemCounter = 1;\n            }\n            activeTag.predicate = this.uriToNamedNode(tag.uri + '_' + parentTag.listItemCounter++);\n        }\n        else {\n            activeTag.predicate = this.uriToNamedNode(tag.uri + tag.local);\n        }\n        // Check forbidden property element names\n        if (tag.uri === RdfXmlParser.RDF\n            && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tag.local) >= 0) {\n            throw this.newParseError(`Illegal property element name: ${tag.local}`);\n        }\n        activeTag.predicateSubPredicates = [];\n        activeTag.predicateSubObjects = [];\n        let parseType = false;\n        let attributedProperty = false;\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubSubjectValue = null;\n        let subSubjectValueBlank = true;\n        const predicates = [];\n        const objects = [];\n        for (const propertyAttributeKey in tag.attributes) {\n            const propertyAttribute = tag.attributes[propertyAttributeKey];\n            if (propertyAttribute.uri === RdfXmlParser.RDF && propertyAttribute.local === 'version') {\n                this.setVersion(activeTag, propertyAttribute.value);\n                continue;\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.RDF) {\n                switch (propertyAttribute.local) {\n                    case 'resource':\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`Found both rdf:resource (${propertyAttribute.value}) and rdf:nodeID (${activeSubSubjectValue}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${propertyAttribute.value})`);\n                        }\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = false;\n                        continue;\n                    case 'datatype':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${propertyAttribute.value})`);\n                        }\n                        activeTag.datatype = this.valueToUri(propertyAttribute.value, activeTag);\n                        continue;\n                    case 'nodeID':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (activeTag.hadChildren) {\n                            throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${propertyAttribute.value})`);\n                        }\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'parseType':\n                        // Validation\n                        if (attributedProperty) {\n                            throw this.newParseError(`rdf:parseType is not allowed when non-rdf:* property attributes are present`);\n                        }\n                        if (activeTag.datatype) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${activeTag.datatype.value})`);\n                        }\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${activeSubSubjectValue})`);\n                        }\n                        if (propertyAttribute.value === 'Resource') {\n                            parseType = true;\n                            activeTag.childrenParseType = ParseType.PROPERTY;\n                            // Turn this property element into a node element\n                            const nestedBNode = this.dataFactory.blankNode();\n                            this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId, activeTag.childrenTripleTerms, activeTag.reifier);\n                            activeTag.subject = nestedBNode;\n                            activeTag.predicate = null;\n                        }\n                        else if (propertyAttribute.value === 'Collection') {\n                            parseType = true;\n                            // Interpret children as being part of an rdf:List\n                            activeTag.hadChildren = true;\n                            activeTag.childrenCollectionSubject = activeTag.subject;\n                            activeTag.childrenCollectionPredicate = activeTag.predicate;\n                            subSubjectValueBlank = false;\n                        }\n                        else if (propertyAttribute.value === 'Literal') {\n                            parseType = true;\n                            // Interpret children as being part of a literal string\n                            activeTag.childrenTagsToString = true;\n                            activeTag.childrenStringTags = [];\n                        }\n                        else if (propertyAttribute.value === 'Triple') {\n                            parseType = true;\n                            // Collect children as triple terms\n                            activeTag.childrenTagsToTripleTerms = true;\n                            activeTag.childrenTripleTerms = [];\n                        }\n                        continue;\n                    case 'ID':\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.reifiedStatementId = this.valueToUri('#' + propertyAttribute.value, activeTag);\n                        this.claimNodeId(activeTag.reifiedStatementId);\n                        continue;\n                    case 'annotation':\n                        activeTag.reifier = this.dataFactory.namedNode(propertyAttribute.value);\n                        continue;\n                    case 'annotationNodeID':\n                        activeTag.reifier = this.dataFactory.blankNode(propertyAttribute.value);\n                        continue;\n                }\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.XML && propertyAttribute.local === 'lang') {\n                activeTag.language = propertyAttribute.value === ''\n                    ? null : propertyAttribute.value.toLowerCase();\n                continue;\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.ITS && propertyAttribute.local === 'dir') {\n                this.setDirection(activeTag, propertyAttribute.value);\n                continue;\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.ITS && propertyAttribute.local === 'version') {\n                // Ignore its:version\n                continue;\n            }\n            // Interpret attributes at this point as properties via implicit blank nodes on the property,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (propertyAttribute.prefix !== 'xml' && propertyAttribute.prefix !== 'xmlns'\n                && (propertyAttribute.prefix !== '' || propertyAttribute.local !== 'xmlns')\n                && propertyAttribute.uri) {\n                if (parseType || activeTag.datatype) {\n                    throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${propertyAttribute.value}`);\n                }\n                activeTag.hadChildren = true;\n                attributedProperty = true;\n                predicates.push(this.uriToNamedNode(propertyAttribute.uri + propertyAttribute.local));\n                objects.push(this.createLiteral(propertyAttribute.value, activeTag));\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubSubjectValue !== null) {\n            const subjectParent = activeTag.subject;\n            activeTag.subject = subSubjectValueBlank\n                ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);\n            this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId, activeTag.childrenTripleTerms, activeTag.reifier);\n            // Emit our buffered triples\n            for (let i = 0; i < predicates.length; i++) {\n                this.emitTriple(activeTag.subject, predicates[i], objects[i], null, activeTag.childrenTripleTerms, activeTag.reifier);\n            }\n            activeTag.predicateEmitted = true;\n        }\n        else if (subSubjectValueBlank) {\n            // The current property element has no defined subject\n            // Let's buffer the properties until the child node defines a subject,\n            // or if the tag closes.\n            activeTag.predicateSubPredicates = predicates;\n            activeTag.predicateSubObjects = objects;\n            activeTag.predicateEmitted = false;\n        }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Term} subject A subject term.\n     * @param {Term} predicate A predicate term.\n     * @param {Term} object An object term.\n     * @param {Term} statementId An optional resource that identifies the triple.\n     *                           If truthy, then the given triple will also be emitted reified.\n     * @param childrenTripleTerms An optional array to push quads into instead of emitting them.\n     * @param reifier The reifier to emit this triple under.\n     */\n    emitTriple(subject, predicate, object, statementId, childrenTripleTerms, reifier) {\n        const quad = this.dataFactory.quad(subject, predicate, object, this.defaultGraph);\n        if (childrenTripleTerms) {\n            childrenTripleTerms.push(quad);\n        }\n        else {\n            this.push(quad);\n        }\n        if (reifier) {\n            this.push(this.dataFactory.quad(reifier, this.dataFactory.namedNode(RdfXmlParser.RDF + 'reifies'), quad));\n        }\n        // Reify triple\n        if (statementId) {\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.dataFactory.namedNode(RdfXmlParser.RDF + 'Statement'), this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'subject'), subject, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'predicate'), predicate, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'object'), object, this.defaultGraph));\n        }\n    }\n    /**\n     * Register the given term as a node ID.\n     * If one was already registered, this will emit an error.\n     *\n     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.\n     * @param {Term} term An RDF term.\n     */\n    claimNodeId(term) {\n        if (!this.allowDuplicateRdfIds) {\n            if (this.nodeIds[term.value]) {\n                throw this.newParseError(`Found multiple occurrences of rdf:ID='${term.value}'.`);\n            }\n            this.nodeIds[term.value] = true;\n        }\n    }\n    /**\n     * Handle the given text string.\n     * @param {string} text A parsed text string.\n     */\n    onText(text) {\n        const activeTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        if (activeTag) {\n            if (activeTag.childrenStringTags) {\n                activeTag.childrenStringTags.push(text);\n            }\n            else if (activeTag.predicate) {\n                activeTag.text = text;\n            }\n        }\n    }\n    /**\n     * Handle the closing of the last tag.\n     */\n    onCloseTag() {\n        const poppedTag = this.activeTagStack.pop();\n        const parentTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        // If we were converting a tag to a string, and the tag was not self-closing, close it here.\n        if (poppedTag.childrenStringEmitClosingTag) {\n            poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);\n        }\n        // Set the literal value if we were collecting XML tags to string\n        if (poppedTag.childrenTagsToString) {\n            poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + 'XMLLiteral');\n            poppedTag.text = poppedTag.childrenStringTags.join('');\n            poppedTag.hadChildren = false; // Force a literal triple to be emitted hereafter\n        }\n        // Set the triple term value if we were collecting triple terms\n        if (poppedTag.childrenTagsToTripleTerms && poppedTag.predicate && poppedTag.rdfVersion) {\n            if (poppedTag.childrenTripleTerms.length !== 1) {\n                throw this.newParseError(`Expected exactly one triple term in rdf:parseType=\"Triple\" but got ${poppedTag.childrenTripleTerms.length}`);\n            }\n            for (const tripleTerm of poppedTag.childrenTripleTerms) {\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, tripleTerm, null, parentTag.childrenTripleTerms, parentTag.reifier);\n            }\n            poppedTag.predicateEmitted = true;\n        }\n        if (poppedTag.childrenCollectionSubject) {\n            // Terminate the rdf:List\n            this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate, this.dataFactory.namedNode(RdfXmlParser.RDF + 'nil'), null, poppedTag.childrenTripleTerms);\n        }\n        else if (poppedTag.predicate) {\n            if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {\n                // Property element contains text\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, this.createLiteral(poppedTag.text || '', poppedTag), poppedTag.reifiedStatementId, poppedTag.childrenTripleTerms, poppedTag.reifier);\n            }\n            else if (!poppedTag.predicateEmitted) {\n                // Emit remaining properties on an anonymous property element\n                const subject = this.dataFactory.blankNode();\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId, poppedTag.childrenTripleTerms, poppedTag.reifier);\n                for (let i = 0; i < poppedTag.predicateSubPredicates.length; i++) {\n                    this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null, poppedTag.childrenTripleTerms);\n                }\n            }\n        }\n    }\n    /**\n     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.\n     * @param {string} doctype The read doctype.\n     */\n    onDoctype(doctype) {\n        doctype.replace(/<!ENTITY\\s+([^\\s]+)\\s+[\"']([^\"']+)[\"']\\s*>/g, (match, prefix, uri) => {\n            this.saxParser.ENTITIES[prefix] = uri;\n            return '';\n        });\n    }\n    setDirection(activeTag, value) {\n        if (value) {\n            if (value !== 'ltr' && value !== 'rtl') {\n                throw this.newParseError(`Base directions must either be 'ltr' or 'rtl', while '${value}' was found.`);\n            }\n            activeTag.direction = value;\n        }\n        else {\n            delete activeTag.direction;\n        }\n    }\n    setVersion(activeTag, version) {\n        activeTag.rdfVersion = version;\n        this.emit('version', version);\n        if (!this.isValidVersion(version)) {\n            throw this.newParseError(`Detected unsupported version: ${version}`);\n        }\n    }\n}\nexports.RdfXmlParser = RdfXmlParser;\nRdfXmlParser.MIME_TYPE = 'application/rdf+xml';\nRdfXmlParser.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nRdfXmlParser.XML = 'http://www.w3.org/XML/1998/namespace';\nRdfXmlParser.ITS = 'http://www.w3.org/2005/11/its';\nRdfXmlParser.FORBIDDEN_NODE_ELEMENTS = [\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'li',\n    'aboutEach',\n    'aboutEachPrefix',\n];\nRdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS = [\n    'Description',\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'aboutEach',\n    'aboutEachPrefix',\n];\n// tslint:disable-next-line:max-line-length\nRdfXmlParser.NCNAME_MATCHER = /^([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_])([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_\\-.0-9#xB7\\u{0300}-\\u{036F}\\u{203F}-\\u{2040}])*$/u;\nRdfXmlParser.SUPPORTED_VERSIONS = [\n    '1.2',\n    '1.2-basic',\n    '1.1',\n];\nvar ParseType;\n(function (ParseType) {\n    ParseType[ParseType[\"RESOURCE\"] = 0] = \"RESOURCE\";\n    ParseType[ParseType[\"PROPERTY\"] = 1] = \"PROPERTY\";\n})(ParseType || (exports.ParseType = ParseType = {}));\n//# sourceMappingURL=RdfXmlParser.js.map"],"names":["Object","defineProperty","exports","value","NamedNode","constructor","this","termType","equals","other","CustomRdfXmlParser","RdfXmlParser","factory","args","super","dataFactory","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","DataFactory","BlankNode_1","DefaultGraph_1","Literal_1","NamedNode_1","Quad_1","Variable_1","dataFactoryCounter","options","blankNodeCounter","blankNodePrefix","namedNode","blankNode","BlankNode","literal","languageOrDatatype","Literal","variable","Variable","defaultGraph","DefaultGraph","INSTANCE","quad","subject","predicate","object","graph","Quad","fromTerm","original","language","datatype","XSD_STRING","fromQuad","resetBlankNodeCounter","resolve","relativeIRI","baseIRI","baseFragmentPos","indexOf","substr","length","Error","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","i","isCharacterAllowedAfterRelativePathSegment","push","pop","map","buffer","join","iri","colonPosition","searchOffset","pathSeparator","base","character","ParseError","parser","message","saxParser","trackPosition","line","column","CHAR","S","NAME_START_CHAR","NAME_CHAR","CHAR_RE","RegExp","S_RE","NAME_START_CHAR_RE","NAME_CHAR_RE","NAME_RE","NMTOKEN_RE","TAB","NL","CR","SPACE","isChar","c","isS","isNameStartChar","isNameChar","S_LIST","buildAbsoluteIriRfc3987Regex","sub_delims_raw","sub_delims","pct_encoded","dec_octet","ipv4address","h16","ls32","ipv6address","ipvfuture","ip_literal","port","scheme","iprivate_raw","iprivate","ucschar_raw","iunreserved_raw","iunreserved","ipchar","ifragment","iquery","isegment_nz","isegment","ipath_empty","ipath_rootless","ipath_absolute","ipath_abempty","ireg_name","ihost","iuserinfo","iauthority","ihier_part","validateIri","IriValidationStrategy","STRICT_IRI_REGEX","PRAGMATIC_IRI_REGEX","strategy","Strict","test","Pragmatic","None","SaxesParser","EVENTS","ed5","ed2","NSed3","isChar10","isChar11","isNCNameStartChar","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","EOC","NL_LIKE","S_BEGIN","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","S_XML_DECL_SEPARATOR","S_XML_DECL_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","NEL","LS","isQuote","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","prefix","uri","fail","nsMappingCheck","mapping","local","keys","isNCName","name","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","EVENT_NAME_TO_HANDLER_NAME","xmldecl","text","processinginstruction","doctype","comment","opentagstart","attribute","opentag","closetag","cdata","error","end","ready","closed","_closed","opt","fragmentOpt","fragment","xmlnsOpt","position","fileName","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","assign","additional","additionalNamespaces","processAttribsPlain","pushAttribPlain","stateTable","sBegin","sBeginWhitespace","sDoctype","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sText","sEntity","sOpenWaka","sOpenWakaBang","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","sPIEnding","sXMLDeclNameStart","sXMLDeclName","sXMLDeclEq","sXMLDeclValueStart","sXMLDeclValue","sXMLDeclSeparator","sXMLDeclEnding","sOpenTag","sOpenTagSlash","sAttrib","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","sCloseTagSawWhite","_init","_a","openWakaBang","piTarget","entity","q","tags","tag","topNS","chunk","chunkPosition","prevI","carriedFromPrevious","forbiddenState","attribList","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","xmlDeclExpects","entityReturnState","defaultXMLVersion","forceXMLVersion","setXMLVersion","positionAtNewLine","xmlDecl","version","encoding","standalone","ENTITIES","readyHandler","columnIndex","on","handler","off","makeError","msg","err","errorHandler","write","toString","limit","lastCode","charCodeAt","slice","close","getCode10","code","final","getCode11","next","getCodeNorm","getCode","unget","captureTo","chars","start","isNLLike","includes","captureToChar","char","captureNameChars","skipSpaces","currentXMLVersion","iBefore","doctypeHandler","String","fromCodePoint","owb","handleTextInRoot","handleTextOutsideRoot","loop","parsed","parseEntity","textHandler","commentHandler","cdataHandler","isQuestion","toLowerCase","piHandler","target","body","xmldeclHandler","attributes","openTagStartHandler","openTag","openSelfClosingTag","closeTag","scanLoop","nonSpace","outRootLoop","qname","attr","attributeHandler","trimmed","trim","_b","endHandler","index","resolvePrefix","colon","JSON","stringify","seen","Set","eqname","has","add","isSelfClosing","openTagHandler","_c","closeTagHandler","top","l","defined","num","NaN","parseInt","NC_NAME_START_CHAR","NC_NAME_CHAR","NC_NAME_START_CHAR_RE","NC_NAME_CHAR_RE","RDF_LANGUAGE_STRING","direction","RDF_DIRECTIONAL_LANGUAGE_STRING","RESTRICTED_CHAR","RESTRICTED_CHAR_RE","isRestrictedChar","isCharAndNotRestricted","ParseType","relative_to_absolute_iri_1","saxes_1","readable_stream_1","ParseError_1","rdf_data_factory_1","validate_iri_1","Transform","readableObjectMode","activeTagStack","nodeIds","validateUri","iriValidationStrategy","parseUnsupportedVersions","attachSaxListeners","import","stream","output","PassThrough","emit","data","pipe","_transform","callback","isValidVersion","newParseError","e","valueToUri","activeTag","uriToNamedNode","uriValidationResult","validateNcname","NCNAME_MATCHER","createLiteral","rdfVersion","SUPPORTED_VERSIONS","onTag","bind","onText","onCloseTag","onDoctype","parentTag","currentParseType","RESOURCE","hadChildren","childrenParseType","childrenStringTags","tagName","key","namespaces","attributeKey","tagContents","tagString","stringActiveTag","childrenStringEmitClosingTag","childrenTripleTerms","onTagResource","onTagProperty","rootTag","PROPERTY","typedNode","RDF","FORBIDDEN_NODE_ELEMENTS","predicates","objects","activeSubjectValue","claimSubjectNodeId","subjectValueBlank","explicitType","XML","ITS","setDirection","setVersion","claimNodeId","type","emitTriple","reifiedStatementId","reifier","childrenCollectionSubject","linkTerm","restTerm","isRestTerm","childrenCollectionPredicate","childrenTagsToTripleTerms","predicateEmitted","predicateSubPredicates","predicateSubObjects","listItemCounter","FORBIDDEN_PROPERTY_ELEMENTS","parseType","attributedProperty","activeSubSubjectValue","subSubjectValueBlank","propertyAttributeKey","propertyAttribute","nestedBNode","childrenTagsToString","subjectParent","statementId","term","allowDuplicateRdfIds","poppedTag","tripleTerm","replace","match","MIME_TYPE"],"ignoreList":[],"sourceRoot":""}