{"version":3,"file":"js/528.c8d4e8af.js","mappings":"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","sources":["webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/NamedNode.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/DataFactory.js","webpack://heat-rapid-triples/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/BlankNode.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/Quad.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/index.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/Literal.js","webpack://heat-rapid-triples/./node_modules/relative-to-absolute-iri/index.js","webpack://heat-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdf-data-factory/lib/Variable.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language, datatype, or directional language.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           If `languageOrDatatype` is a NamedNode, it is used for the value\n     *                           of `NamedNode.language`.\n     *                           Otherwise, it is used as a directional language,\n     *                           from which the language is set to `languageOrDatatype.language`\n     *                           and the direction to `languageOrDatatype.direction`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal,\n * containing a string with an optional language tag and optional direction\n * or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n            this.direction = '';\n        }\n        else if (languageOrDatatype) {\n            if ('termType' in languageOrDatatype) {\n                this.language = '';\n                this.datatype = languageOrDatatype;\n                this.direction = '';\n            }\n            else {\n                this.language = languageOrDatatype.language;\n                this.datatype = languageOrDatatype.direction ?\n                    Literal.RDF_DIRECTIONAL_LANGUAGE_STRING :\n                    Literal.RDF_LANGUAGE_STRING;\n                this.direction = languageOrDatatype.direction || '';\n            }\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n            this.direction = '';\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language &&\n            ((other.direction === this.direction) || (!other.direction && this.direction === '')) &&\n            this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.RDF_DIRECTIONAL_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map"],"names":["Object","defineProperty","exports","value","NamedNode","constructor","this","termType","equals","other","DataFactory","BlankNode_1","DefaultGraph_1","Literal_1","NamedNode_1","Quad_1","Variable_1","dataFactoryCounter","options","blankNodeCounter","blankNodePrefix","namedNode","blankNode","BlankNode","literal","languageOrDatatype","Literal","variable","Variable","defaultGraph","DefaultGraph","INSTANCE","quad","subject","predicate","object","graph","Quad","fromTerm","original","language","datatype","XSD_STRING","fromQuad","resetBlankNodeCounter","resolve","relativeIRI","baseIRI","baseFragmentPos","indexOf","substr","length","Error","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","i","isCharacterAllowedAfterRelativePathSegment","push","pop","map","buffer","join","iri","colonPosition","searchOffset","pathSeparator","base","character","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","RDF_LANGUAGE_STRING","direction","RDF_DIRECTIONAL_LANGUAGE_STRING"],"ignoreList":[],"sourceRoot":""}