{"version":3,"file":"js/109.adc34c25.js","mappings":"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","sources":["webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeyword.js","webpack://heat-rapid-triples/./node_modules/http-link-header/lib/link.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/ContextTree.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/fromTerm.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/index.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/Util.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/index.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/BlankNode.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordId.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/sink/index.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerInvalidFallback.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordContext.js","webpack://heat-rapid-triples/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordNest.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/IDocumentLoader.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/node_modules/canonicalize/lib/canonicalize.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordValue.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/Quad.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/index.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/index.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/NamedNode.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/JsonLdContext.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/Variable.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/index.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/Literal.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/BlankNode.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/JsonLdParser.js","webpack://heat-rapid-triples/./node_modules/jsonparse/jsonparse.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordGraph.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/Literal.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/lib/ParserStream.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordIncluded.js","webpack://heat-rapid-triples/./node_modules/relative-to-absolute-iri/index.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/ContextParser.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/ErrorCoded.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/DefaultGraph.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/DataFactory.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/Quad.js","webpack://heat-rapid-triples/./node_modules/@rdfjs/parser-jsonld/node_modules/@rdfjs/data-model/lib/NamedNode.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordUnknownFallback.js","webpack://heat-rapid-triples/./node_modules/cross-fetch/dist/browser-polyfill.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/Variable.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/DataFactory.js","webpack://heat-rapid-triples/./node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://heat-rapid-triples/./node_modules/jsonld-streaming-parser/lib/ParsingContext.js","webpack://heat-rapid-triples/./node_modules/jsonld-context-parser/lib/Util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeyword = void 0;\n/**\n * An abstract keyword entry handler.\n */\nclass EntryHandlerKeyword {\n    constructor(keyword) {\n        this.keyword = keyword;\n    }\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return key === this.keyword;\n    }\n}\nexports.EntryHandlerKeyword = EntryHandlerKeyword;\n//# sourceMappingURL=EntryHandlerKeyword.js.map","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ].rel === 'string' && this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isnt already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextTree = void 0;\n/**\n * A tree structure that holds all contexts,\n * based on their position in the JSON object.\n *\n * Positions are identified by a path of keys.\n */\nclass ContextTree {\n    constructor() {\n        this.subTrees = {};\n    }\n    getContext(keys) {\n        if (keys.length > 0) {\n            const [head, ...tail] = keys;\n            const subTree = this.subTrees[head];\n            if (subTree) {\n                const subContext = subTree.getContext(tail);\n                if (subContext) {\n                    return subContext.then(({ context, depth }) => ({ context, depth: depth + 1 }));\n                }\n            }\n        }\n        return this.context ? this.context.then((context) => ({ context, depth: 0 })) : null;\n    }\n    setContext(keys, context) {\n        if (keys.length === 0) {\n            this.context = context;\n        }\n        else {\n            const [head, ...tail] = keys;\n            let subTree = this.subTrees[head];\n            if (!subTree) {\n                subTree = this.subTrees[head] = new ContextTree();\n            }\n            subTree.setContext(tail, context);\n        }\n    }\n    removeContext(path) {\n        this.setContext(path, null);\n    }\n}\nexports.ContextTree = ContextTree;\n//# sourceMappingURL=ContextTree.js.map","function fromTerm (original) {\n  if (!original) {\n    return null\n  }\n\n  if (original.termType === 'BlankNode') {\n    return this.blankNode(original.value)\n  }\n\n  if (original.termType === 'DefaultGraph') {\n    return this.defaultGraph()\n  }\n\n  if (original.termType === 'Literal') {\n    return this.literal(original.value, original.language || this.namedNode(original.datatype.value))\n  }\n\n  if (original.termType === 'NamedNode') {\n    return this.namedNode(original.value)\n  }\n\n  if (original.termType === 'Quad') {\n    const subject = this.fromTerm(original.subject)\n    const predicate = this.fromTerm(original.predicate)\n    const object = this.fromTerm(original.object)\n    const graph = this.fromTerm(original.graph)\n\n    return this.quad(subject, predicate, object, graph)\n  }\n\n  if (original.termType === 'Variable') {\n    return this.variable(original.value)\n  }\n\n  throw new Error(`unknown termType ${original.termType}`)\n}\n\nmodule.exports = fromTerm\n","const Sink = require('@rdfjs/sink')\nconst ParserStream = require('./lib/ParserStream')\n\nclass Parser extends Sink {\n  constructor (options) {\n    super(ParserStream, options)\n  }\n}\n\nmodule.exports = Parser\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerIdentifier = void 0;\n/**\n * Container handler for @id.\n *\n * It assumes that the current key is the identifier of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerIdentifier {\n    canCombineWithGraph() {\n        return true;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        let id;\n        // First check if the child node already has a defined id.\n        if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {\n            // Use the existing identifier\n            id = parsingContext.idStack[depth + 1][0];\n        }\n        else {\n            // Create the identifier\n            const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);\n            const maybeId = keyUnaliased !== null\n                ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth])\n                : util.dataFactory.blankNode();\n            // Do nothing if the id is invalid\n            if (!maybeId) {\n                parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n                return;\n            }\n            id = maybeId;\n            // Insert the id into the stack so that buffered children can make us of it.\n            parsingContext.idStack[depth + 1] = [id];\n        }\n        // Insert the id into the stack so that parents can make use of it.\n        // Insert it as an array because multiple id container entries may exist\n        let ids = parsingContext.idStack[depth];\n        if (!ids) {\n            ids = parsingContext.idStack[depth] = [];\n        }\n        // Only insert the term if it does not exist yet in the array.\n        if (!ids.some((term) => term.equals(id))) {\n            ids.push(id);\n        }\n        // Flush any pending flush buffers\n        if (!await parsingContext.handlePendingContainerFlushBuffers()) {\n            parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n        }\n    }\n}\nexports.ContainerHandlerIdentifier = ContainerHandlerIdentifier;\n//# sourceMappingURL=ContainerHandlerIdentifier.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst EntryHandlerContainer_1 = require(\"./entryhandler/EntryHandlerContainer\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Utility functions and methods.\n */\nclass Util {\n    constructor(options) {\n        this.parsingContext = options.parsingContext;\n        this.dataFactory = options.dataFactory || new rdf_data_factory_1.DataFactory();\n        this.rdfFirst = this.dataFactory.namedNode(Util.RDF + 'first');\n        this.rdfRest = this.dataFactory.namedNode(Util.RDF + 'rest');\n        this.rdfNil = this.dataFactory.namedNode(Util.RDF + 'nil');\n        this.rdfType = this.dataFactory.namedNode(Util.RDF + 'type');\n        this.rdfJson = this.dataFactory.namedNode(Util.RDF + 'JSON');\n    }\n    /**\n     * Helper function to get the value of a context entry,\n     * or fallback to a certain value.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} contextKey A pre-defined JSON-LD key in context entries.\n     * @param {string} key A context entry key.\n     * @param {string} fallback A fallback value for when the given contextKey\n     *                          could not be found in the value with the given key.\n     * @return {string} The value of the given contextKey in the entry behind key in the given context,\n     *                  or the given fallback value.\n     */\n    static getContextValue(context, contextKey, key, fallback) {\n        const entry = context.getContextRaw()[key];\n        if (!entry) {\n            return fallback;\n        }\n        const type = entry[contextKey];\n        return type === undefined ? fallback : type;\n    }\n    /**\n     * Get the container type of the given key in the context.\n     *\n     * Should any context-scoping bugs should occur related to this in the future,\n     * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).\n     * This is because containers act 2 levels deep.\n     *\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The container type.\n     */\n    static getContextValueContainer(context, key) {\n        return Util.getContextValue(context, '@container', key, { '@set': true });\n    }\n    /**\n     * Get the value type of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueType(context, key) {\n        const valueType = Util.getContextValue(context, '@type', key, null);\n        if (valueType === '@none') {\n            return null;\n        }\n        return valueType;\n    }\n    /**\n     * Get the language of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueLanguage(context, key) {\n        return Util.getContextValue(context, '@language', key, context.getContextRaw()['@language'] || null);\n    }\n    /**\n     * Get the direction of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueDirection(context, key) {\n        return Util.getContextValue(context, '@direction', key, context.getContextRaw()['@direction'] || null);\n    }\n    /**\n     * Check if the given key in the context is a reversed property.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {boolean} If the context value has a @reverse key.\n     */\n    static isContextValueReverse(context, key) {\n        return !!Util.getContextValue(context, '@reverse', key, null);\n    }\n    /**\n     * Get the @index of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The index.\n     */\n    static getContextValueIndex(context, key) {\n        return Util.getContextValue(context, '@index', key, context.getContextRaw()['@index'] || null);\n    }\n    /**\n     * Check if the given key refers to a reversed property.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The property key.\n     * @param {string} parentKey The parent key.\n     * @return {boolean} If the property must be reversed.\n     */\n    static isPropertyReverse(context, key, parentKey) {\n        // '!==' is needed because reversed properties in a @reverse container should cancel each other out.\n        return parentKey === '@reverse' !== Util.isContextValueReverse(context, key);\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return iri !== null && jsonld_context_parser_1.Util.isValidIri(iri);\n    }\n    /**\n     * Check if the given first array (needle) is a prefix of the given second array (haystack).\n     * @param needle An array to check if it is a prefix.\n     * @param haystack An array to look in.\n     */\n    static isPrefixArray(needle, haystack) {\n        if (needle.length > haystack.length) {\n            return false;\n        }\n        for (let i = 0; i < needle.length; i++) {\n            if (needle[i] !== haystack[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Make sure that @id-@index pairs are equal over all array values.\n     * Reject otherwise.\n     * @param {any[]} value An array value.\n     * @return {Promise<void>} A promise rejecting if conflicts are present.\n     */\n    async validateValueIndexes(value) {\n        if (this.parsingContext.validateValueIndexes) {\n            const indexHashes = {};\n            for (const entry of value) {\n                if (entry && typeof entry === 'object') {\n                    const id = entry['@id'];\n                    const index = entry['@index'];\n                    if (id && index) {\n                        const existingIndexValue = indexHashes[id];\n                        if (existingIndexValue && existingIndexValue !== index) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Conflicting @index value for ${id}`, jsonld_context_parser_1.ERROR_CODES.CONFLICTING_INDEXES);\n                        }\n                        indexHashes[id] = index;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert a given JSON value to an RDF term.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The current JSON key.\n     * @param value A JSON value.\n     * @param {number} depth The depth the value is at.\n     * @param {string[]} keys The path of keys.\n     * @return {Promise<RDF.Term[]>} An RDF term array.\n     */\n    async valueToTerm(context, key, value, depth, keys) {\n        // Skip further processing if we have an @type: @json\n        if (Util.getContextValueType(context, key) === '@json') {\n            return [this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson)];\n        }\n        const type = typeof value;\n        switch (type) {\n            case 'object':\n                // Skip if we have a null or undefined object\n                if (value === null || value === undefined) {\n                    return [];\n                }\n                // Special case for arrays\n                if (Array.isArray(value)) {\n                    // We handle arrays at value level so we can emit earlier, so this is handled already when we get here.\n                    // Empty context-based lists are emitted at this place, because our streaming algorithm doesn't detect those.\n                    if ('@list' in Util.getContextValueContainer(context, key)) {\n                        if (value.length === 0) {\n                            return [this.rdfNil];\n                        }\n                        else {\n                            return this.parsingContext.idStack[depth + 1] || [];\n                        }\n                    }\n                    await this.validateValueIndexes(value);\n                    return [];\n                }\n                // Handle property-scoped contexts\n                context = await this.getContextSelfOrPropertyScoped(context, key);\n                // Handle local context in the value\n                if ('@context' in value) {\n                    context = await this.parsingContext.parseContext(value['@context'], (await this.parsingContext.getContext(keys, 0)).getContextRaw());\n                }\n                // In all other cases, we have a hash\n                value = await this.unaliasKeywords(value, keys, depth, context); // Un-alias potential keywords in this hash\n                if ('@value' in value) {\n                    let val;\n                    let valueLanguage;\n                    let valueDirection;\n                    let valueType;\n                    let valueIndex; // We don't use the index, but we need to check its type for spec-compliance\n                    for (key in value) {\n                        const subValue = value[key];\n                        switch (key) {\n                            case '@value':\n                                val = subValue;\n                                break;\n                            case '@language':\n                                valueLanguage = subValue;\n                                break;\n                            case '@direction':\n                                valueDirection = subValue;\n                                break;\n                            case '@type':\n                                valueType = subValue;\n                                break;\n                            case '@index':\n                                valueIndex = subValue;\n                                break;\n                            default:\n                                throw new jsonld_context_parser_1.ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                    }\n                    // Skip further processing if we have an @type: @json\n                    if (await this.unaliasKeyword(valueType, keys, depth, true, context) === '@json') {\n                        return [this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson)];\n                    }\n                    // Validate @value\n                    if (val === null) {\n                        return [];\n                    }\n                    if (typeof val === 'object') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);\n                    }\n                    // Validate @index\n                    if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== 'string') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE);\n                    }\n                    // Validate @language and @direction\n                    if (valueLanguage) {\n                        if (typeof val !== 'string') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);\n                        }\n                        if (!jsonld_context_parser_1.ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {\n                            return [];\n                        }\n                        // Language tags are always normalized to lowercase in 1.0.\n                        if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1.0) {\n                            valueLanguage = valueLanguage.toLowerCase();\n                        }\n                    }\n                    if (valueDirection) {\n                        if (typeof val !== 'string') {\n                            throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);\n                        }\n                        if (!jsonld_context_parser_1.ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {\n                            return [];\n                        }\n                    }\n                    // Check @language and @direction\n                    if (valueLanguage && valueDirection && this.parsingContext.rdfDirection) {\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON\n                                .stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return this.nullableTermToArray(this\n                            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n                    }\n                    else if (valueLanguage) { // Check @language\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return [this.dataFactory.literal(val, valueLanguage)];\n                    }\n                    else if (valueDirection && this.parsingContext.rdfDirection) { // Check @direction\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return this.nullableTermToArray(this\n                            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n                    }\n                    else if (valueType) { // Validate @type\n                        if (typeof valueType !== 'string') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        const typeTerm = this.createVocabOrBaseTerm(context, valueType);\n                        if (!typeTerm) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        if (typeTerm.termType !== 'NamedNode') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        return [this.dataFactory.literal(val, typeTerm)];\n                    }\n                    // We don't pass the context, because context-based things like @language should be ignored\n                    return await this.valueToTerm(new jsonld_context_parser_1.JsonLdContextNormalized({}), key, val, depth, keys);\n                }\n                else if ('@set' in value) {\n                    // No other entries are allow in this value\n                    if (Object.keys(value).length > 1) {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n                    }\n                    // No need to do anything here, this is handled at the deeper level.\n                    return [];\n                }\n                else if ('@list' in value) {\n                    // No other entries are allowed in this value\n                    if (Object.keys(value).length > 1) {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n                    }\n                    const listValue = value[\"@list\"];\n                    // We handle lists at value level so we can emit earlier, so this is handled already when we get here.\n                    // Empty anonymous lists are emitted at this place, because our streaming algorithm doesn't detect those.\n                    if (Array.isArray(listValue)) {\n                        if (listValue.length === 0) {\n                            return [this.rdfNil];\n                        }\n                        else {\n                            return this.parsingContext.idStack[depth + 1] || [];\n                        }\n                    }\n                    else {\n                        // We only have a single list element here, so emit this directly as single element\n                        return await this.valueToTerm(await this.parsingContext.getContext(keys), key, listValue, depth - 1, keys.slice(0, -1));\n                    }\n                }\n                else if ('@reverse' in value && typeof value['@reverse'] === 'boolean') {\n                    // We handle reverse properties at value level so we can emit earlier,\n                    // so this is handled already when we get here.\n                    return [];\n                }\n                else if ('@graph' in Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {\n                    // We are processing a graph container\n                    const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];\n                    return graphContainerEntries ? Object.values(graphContainerEntries) : [this.dataFactory.blankNode()];\n                }\n                else if (\"@id\" in value) {\n                    // Use deeper context if the value node contains other properties next to @id.\n                    if (Object.keys(value).length > 1) {\n                        context = await this.parsingContext.getContext(keys, 0);\n                    }\n                    // Handle local context in the value\n                    if ('@context' in value) {\n                        context = await this.parsingContext.parseContext(value['@context'], context.getContextRaw());\n                    }\n                    if (value[\"@type\"] === '@vocab') {\n                        return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value[\"@id\"]));\n                    }\n                    else {\n                        return this.nullableTermToArray(this.resourceToTerm(context, value[\"@id\"]));\n                    }\n                }\n                else {\n                    // Only make a blank node if at least one triple was emitted at the value's level.\n                    if (this.parsingContext.emittedStack[depth + 1]\n                        || (value && typeof value === 'object' && Object.keys(value).length === 0)) {\n                        return (this.parsingContext.idStack[depth + 1]\n                            || (this.parsingContext.idStack[depth + 1] = [this.dataFactory.blankNode()]));\n                    }\n                    else {\n                        return [];\n                    }\n                }\n            case 'string':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, null));\n            case 'boolean':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(), this.dataFactory.namedNode(Util.XSD_BOOLEAN)));\n            case 'number':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(value % 1 === 0 && value < 1e21 ? Util.XSD_INTEGER : Util.XSD_DOUBLE)));\n            default:\n                this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type}`));\n                return [];\n        }\n    }\n    /**\n     * If the context defines a property-scoped context for the given key,\n     * that context will be returned.\n     * Otherwise, the given context will be returned as-is.\n     *\n     * This should be used for valueToTerm cases that are not objects.\n     * @param context A context.\n     * @param key A JSON key.\n     */\n    async getContextSelfOrPropertyScoped(context, key) {\n        const contextKeyEntry = context.getContextRaw()[key];\n        if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n            context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);\n        }\n        return context;\n    }\n    /**\n     * If the given term is null, return an empty array, otherwise return an array with the single given term.\n     * @param term A term.\n     */\n    nullableTermToArray(term) {\n        return term ? [term] : [];\n    }\n    /**\n     * Convert a given JSON key to an RDF predicate term,\n     * based on @vocab.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node.\n     */\n    predicateToTerm(context, key) {\n        const expanded = context.expandTerm(key, true, this.parsingContext.getExpandOptions());\n        // Immediately return if the predicate was disabled in the context\n        if (!expanded) {\n            return null;\n        }\n        // Check if the predicate is a blank node\n        if (expanded[0] === '_' && expanded[1] === ':') {\n            if (this.parsingContext.produceGeneralizedRdf) {\n                return this.dataFactory.blankNode(expanded.substr(2));\n            }\n            else {\n                return null;\n            }\n        }\n        // Check if the predicate is a valid IRI\n        if (Util.isValidIri(expanded)) {\n            return this.dataFactory.namedNode(expanded);\n        }\n        else {\n            if (expanded && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid predicate IRI: ${expanded}`, jsonld_context_parser_1.ERROR_CODES.INVALID_IRI_MAPPING));\n            }\n            else {\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Convert a given JSON key to an RDF resource term or blank node,\n     * based on @base.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node or null.\n     */\n    resourceToTerm(context, key) {\n        if (key.startsWith('_:')) {\n            return this.dataFactory.blankNode(key.substr(2));\n        }\n        const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());\n        if (!Util.isValidIri(iri)) {\n            if (iri && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));\n            }\n            else {\n                return null;\n            }\n        }\n        return this.dataFactory.namedNode(iri);\n    }\n    /**\n     * Convert a given JSON key to an RDF resource term.\n     * It will do this based on the @vocab,\n     * and fallback to @base.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node or null.\n     */\n    createVocabOrBaseTerm(context, key) {\n        if (key.startsWith('_:')) {\n            return this.dataFactory.blankNode(key.substr(2));\n        }\n        const expandOptions = this.parsingContext.getExpandOptions();\n        let expanded = context.expandTerm(key, true, expandOptions);\n        if (expanded === key) {\n            expanded = context.expandTerm(key, false, expandOptions);\n        }\n        if (!Util.isValidIri(expanded)) {\n            if (expanded && this.parsingContext.strictValues && !expanded.startsWith('@')) {\n                this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));\n            }\n            else {\n                return null;\n            }\n        }\n        return this.dataFactory.namedNode(expanded);\n    }\n    /**\n     * Ensure that the given value becomes a string.\n     * @param {string | number} value A string or number.\n     * @param {NamedNode} datatype The intended datatype.\n     * @return {string} The returned string.\n     */\n    intToString(value, datatype) {\n        if (typeof value === 'number') {\n            if (Number.isFinite(value)) {\n                const isInteger = value % 1 === 0;\n                if (isInteger && (!datatype || datatype.value !== Util.XSD_DOUBLE)) {\n                    return Number(value).toString();\n                }\n                else {\n                    return value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n                }\n            }\n            else {\n                return value > 0 ? 'INF' : '-INF';\n            }\n        }\n        else {\n            return value;\n        }\n    }\n    /**\n     * Convert a given JSON string value to an RDF term.\n     * @param {number} depth The current stack depth.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The current JSON key.\n     * @param {string} value A JSON value.\n     * @param {NamedNode} defaultDatatype The default datatype for the given value.\n     * @return {RDF.Term} An RDF term or null.\n     */\n    stringValueToTerm(depth, context, key, value, defaultDatatype) {\n        // Check the datatype from the context\n        const contextType = Util.getContextValueType(context, key);\n        if (contextType) {\n            if (contextType === '@id') {\n                if (!defaultDatatype) {\n                    return this.resourceToTerm(context, this.intToString(value, defaultDatatype));\n                }\n            }\n            else if (contextType === '@vocab') {\n                if (!defaultDatatype) {\n                    return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));\n                }\n            }\n            else {\n                defaultDatatype = this.dataFactory.namedNode(contextType);\n            }\n        }\n        // If we don't find such a datatype, check the language from the context\n        if (!defaultDatatype) {\n            const contextLanguage = Util.getContextValueLanguage(context, key);\n            const contextDirection = Util.getContextValueDirection(context, key);\n            if (contextDirection && this.parsingContext.rdfDirection) {\n                return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype), contextLanguage, contextDirection);\n            }\n            else {\n                return this.dataFactory.literal(this.intToString(value, defaultDatatype), contextLanguage);\n            }\n        }\n        // If all else fails, make a literal based on the default content type\n        return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);\n    }\n    /**\n     * Create a literal for the given value with the given language and direction.\n     * Auxiliary quads may be emitted.\n     * @param {number} depth The current stack depth.\n     * @param {string} value A string value.\n     * @param {string} language A language tag.\n     * @param {string} direction A direction.\n     * @return {Term} An RDF term.\n     */\n    createLanguageDirectionLiteral(depth, value, language, direction) {\n        if (this.parsingContext.rdfDirection === 'i18n-datatype') {\n            // Create a datatyped literal, by encoding the language and direction into https://www.w3.org/ns/i18n#.\n            if (!language) {\n                language = '';\n            }\n            return this.dataFactory.literal(value, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));\n        }\n        else {\n            // Reify the literal.\n            const valueNode = this.dataFactory.blankNode();\n            const graph = this.getDefaultGraph();\n            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'value'), this.dataFactory.literal(value), graph));\n            if (language) {\n                this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'language'), this.dataFactory.literal(language), graph));\n            }\n            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'direction'), this.dataFactory.literal(direction), graph));\n            return valueNode;\n        }\n    }\n    /**\n     * Stringify the given JSON object to a canonical JSON string.\n     * @param value Any valid JSON value.\n     * @return {string} A canonical JSON string.\n     */\n    valueToJsonString(value) {\n        return canonicalizeJson(value);\n    }\n    /**\n     * If the key is not a keyword, try to check if it is an alias for a keyword,\n     * and if so, un-alias it.\n     * @param {string} key A key, can be falsy.\n     * @param {string[]} keys The path of keys.\n     * @param {number} depth The depth to\n     * @param {boolean} disableCache If the cache should be disabled\n     * @param {JsonLdContextNormalized} context A context to unalias with,\n     *                                           will fallback to retrieving the context for the given keys.\n     * @return {Promise<string>} A promise resolving to the key itself, or another key.\n     */\n    async unaliasKeyword(key, keys, depth, disableCache, context) {\n        // Numbers can not be an alias\n        if (Number.isInteger(key)) {\n            return key;\n        }\n        // Try to grab from cache if it was already un-aliased before.\n        if (!disableCache) {\n            const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];\n            if (cachedUnaliasedKeyword) {\n                return cachedUnaliasedKeyword;\n            }\n        }\n        if (!jsonld_context_parser_1.Util.isPotentialKeyword(key)) {\n            context = context || await this.parsingContext.getContext(keys);\n            let unliased = context.getContextRaw()[key];\n            if (unliased && typeof unliased === 'object') {\n                unliased = unliased['@id'];\n            }\n            if (jsonld_context_parser_1.Util.isValidKeyword(unliased)) {\n                key = unliased;\n            }\n        }\n        return disableCache ? key : (this.parsingContext.unaliasedKeywordCacheStack[depth] = key);\n    }\n    /**\n     * Unalias the keyword of the parent.\n     * This adds a safety check if no parent exist.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<any>} A promise resolving to the parent key, or another key.\n     */\n    async unaliasKeywordParent(keys, depth) {\n        return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);\n    }\n    /**\n     * Un-alias all keywords in the given hash.\n     * @param {{[p: string]: any}} hash A hash object.\n     * @param {string[]} keys The path of keys.\n     * @param {number} depth The depth.\n     * @param {JsonLdContextNormalized} context A context to unalias with,\n     *                                           will fallback to retrieving the context for the given keys.\n     * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.\n     */\n    async unaliasKeywords(hash, keys, depth, context) {\n        const newHash = {};\n        for (const key in hash) {\n            newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash[key];\n        }\n        return newHash;\n    }\n    /**\n     * Check if we are processing a literal (including JSON literals) at the given depth.\n     * This will also check higher levels,\n     * because if a parent is a literal,\n     * then the deeper levels are definitely a literal as well.\n     * @param {number} depth The depth.\n     * @return {boolean} If we are processing a literal.\n     */\n    isLiteral(depth) {\n        for (let i = depth; i >= 0; i--) {\n            if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check how many parents should be skipped for checking the @graph for the given node.\n     *\n     * @param {number} depth The depth of the node.\n     * @param {any[]} keys An array of keys.\n     * @return {number} The graph depth offset.\n     */\n    async getDepthOffsetGraph(depth, keys) {\n        for (let i = depth - 1; i > 0; i--) {\n            if (await this.unaliasKeyword(keys[i], keys, i) === '@graph') {\n                // Skip further processing if we are already in an @graph-@id or @graph-@index container\n                const containers = (await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;\n                if (EntryHandlerContainer_1.EntryHandlerContainer.isComplexGraphContainer(containers)) {\n                    return -1;\n                }\n                return depth - i - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Check if the given subject is of a valid type.\n     * This should be called when applying @reverse'd properties.\n     * @param {Term} subject A subject.\n     */\n    validateReverseSubject(subject) {\n        if (subject.termType === 'Literal') {\n            throw new jsonld_context_parser_1.ErrorCoded(`Found illegal literal in subject position: ${subject.value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n        }\n    }\n    /**\n     * Get the default graph.\n     * @return {Term} An RDF term.\n     */\n    getDefaultGraph() {\n        return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();\n    }\n    /**\n     * Get the current graph, while taking into account a graph that can be defined via @container: @graph.\n     * If not within a graph container, the default graph will be returned.\n     * @param keys The current keys.\n     * @param depth The current depth.\n     */\n    async getGraphContainerValue(keys, depth) {\n        // Default to default graph\n        let graph = this.getDefaultGraph();\n        // Check if we are in an @container: @graph.\n        const { containers, depth: depthContainer } = await EntryHandlerContainer_1.EntryHandlerContainer\n            .getContainerHandler(this.parsingContext, keys, depth);\n        if ('@graph' in containers) {\n            // Get the graph from the stack.\n            const graphContainerIndex = EntryHandlerContainer_1.EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);\n            const entry = this.parsingContext.graphContainerTermStack[depthContainer];\n            graph = entry ? entry[graphContainerIndex] : null;\n            // Set the graph in the stack if none has been set yet.\n            if (!graph) {\n                let graphId = null;\n                if ('@id' in containers) {\n                    const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);\n                    if (keyUnaliased !== null) {\n                        graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);\n                    }\n                }\n                if (!graphId) {\n                    graphId = this.dataFactory.blankNode();\n                }\n                if (!this.parsingContext.graphContainerTermStack[depthContainer]) {\n                    this.parsingContext.graphContainerTermStack[depthContainer] = {};\n                }\n                graph = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;\n            }\n        }\n        return graph;\n    }\n    /**\n     * Get the properties depth for retrieving properties.\n     *\n     * Typically, the properties depth will be identical to the given depth.\n     *\n     * The following exceptions apply:\n     * * When the parent is @reverse, the depth is decremented by one.\n     * * When @nest parents are found, the depth is decremented by the number of @nest parents.\n     * If in combination with the exceptions above an intermediary array is discovered,\n     * the depth is also decremented by this number of arrays.\n     *\n     * @param keys The current key chain.\n     * @param depth The current depth.\n     */\n    async getPropertiesDepth(keys, depth) {\n        let lastValidDepth = depth;\n        for (let i = depth - 1; i > 0; i--) {\n            if (typeof keys[i] !== 'number') { // Skip array keys\n                const parentKey = await this.unaliasKeyword(keys[i], keys, i);\n                if (parentKey === '@reverse') {\n                    return i;\n                }\n                else if (parentKey === '@nest') {\n                    lastValidDepth = i;\n                }\n                else {\n                    return lastValidDepth;\n                }\n            }\n        }\n        return lastValidDepth;\n    }\n    /**\n     * Get the key for the current container entry.\n     * @param key A key, can be falsy.\n     * @param keys The key chain.\n     * @param depth The current depth to get the key from.\n     * @return Promise resolving to the key.\n     *         Null will be returned for @none entries, with aliasing taken into account.\n     */\n    async getContainerKey(key, keys, depth) {\n        const keyUnaliased = await this.unaliasKeyword(key, keys, depth);\n        return keyUnaliased === '@none' ? null : keyUnaliased;\n    }\n}\nexports.Util = Util;\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.XSD_BOOLEAN = Util.XSD + 'boolean';\nUtil.XSD_INTEGER = Util.XSD + 'integer';\nUtil.XSD_DOUBLE = Util.XSD + 'double';\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n//# sourceMappingURL=Util.js.map","const DataFactory = require('./lib/DataFactory.js')\n\nmodule.exports = DataFactory\n","class BlankNode {\n  constructor (id) {\n    this.value = id || ('b' + (++BlankNode.nextId))\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value\n  }\n}\n\nBlankNode.prototype.termType = 'BlankNode'\n\nBlankNode.nextId = 0\n\nmodule.exports = BlankNode\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordId = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @id entries.\n */\nclass EntryHandlerKeywordId extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@id');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        if (typeof value !== 'string') {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @id '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_ID_VALUE));\n        }\n        // Determine the canonical place for this id.\n        // For example, @nest parents should be ignored.\n        const depthProperties = await util.getPropertiesDepth(keys, depth);\n        // Error if an @id for this node already existed.\n        if (parsingContext.idStack[depthProperties] !== undefined) {\n            if (parsingContext.idStack[depthProperties][0].listHead) {\n                // Error if an @list was already defined for this node\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${keys[depth - 1]}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT));\n            }\n            else {\n                // Otherwise, the previous id was just because of an @id entry.\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found duplicate @ids '${parsingContext\n                    .idStack[depthProperties][0].value}' and '${value}'`, jsonld_context_parser_1.ERROR_CODES.COLLIDING_KEYWORDS));\n            }\n        }\n        // Save our @id on the stack\n        parsingContext.idStack[depthProperties] = util.nullableTermToArray(await util.resourceToTerm(await parsingContext.getContext(keys), value));\n    }\n}\nexports.EntryHandlerKeywordId = EntryHandlerKeywordId;\n//# sourceMappingURL=EntryHandlerKeywordId.js.map","class Sink {\n  constructor (Impl, options) {\n    this.Impl = Impl\n    this.options = options\n  }\n\n  import (input, options) {\n    const output = new this.Impl(input, Object.assign({}, this.options, options))\n\n    input.on('end', () => {\n      if (!output.readable) {\n        output.emit('end')\n      }\n    })\n\n    input.on('error', (err) => {\n      output.emit('error', err)\n    })\n\n    return output\n  }\n}\n\nmodule.exports = Sink\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerInvalidFallback = void 0;\n/**\n * A catch-all for properties, that will either emit an error or ignore,\n * depending on whether or not the `strictValues` property is set.\n */\nclass EntryHandlerInvalidFallback {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return true;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerInvalidFallback = EntryHandlerInvalidFallback;\n//# sourceMappingURL=EntryHandlerInvalidFallback.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordContext = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @context entries.\n */\nclass EntryHandlerKeywordContext extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@context');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // Error if an out-of-order context was found when support is not enabled.\n        if (parsingContext.streamingProfile\n            && (parsingContext.processingStack[depth]\n                || parsingContext.processingType[depth]\n                || parsingContext.idStack[depth] !== undefined)) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded('Found an out-of-order context, while streaming is enabled.' +\n                '(disable `streamingProfile`)', jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n        }\n        // Find the parent context to inherit from.\n        // We actually request a context for the current depth (with fallback to parent)\n        // because we want to take into account any property-scoped contexts that are defined for this depth.\n        const parentContext = parsingContext.getContext(keys);\n        // Set the context for this scope\n        const context = parsingContext.parseContext(value, (await parentContext).getContextRaw());\n        parsingContext.contextTree.setContext(keys.slice(0, -1), context);\n        parsingContext.emitContext(value);\n        await parsingContext.validateContext(await context);\n    }\n}\nexports.EntryHandlerKeywordContext = EntryHandlerKeywordContext;\n//# sourceMappingURL=EntryHandlerKeywordContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordNest = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @nest entries.\n */\nclass EntryHandlerKeywordNest extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@nest');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        if (typeof value !== 'object') {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found invalid @nest entry for '${key}': '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));\n        }\n        if ('@value' in await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys))) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an invalid @value node for '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));\n        }\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordNest = EntryHandlerKeywordNest;\n//# sourceMappingURL=EntryHandlerKeywordNest.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IDocumentLoader.js.map","/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordValue = void 0;\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @value entries.\n */\nclass EntryHandlerKeywordValue extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@value');\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        // If this is @value, mark it so in the stack so that no deeper handling of nodes occurs.\n        const key = keys[depth];\n        if (key && !parsingContext.literalStack[depth] && await this.test(parsingContext, util, key, keys, depth)) {\n            parsingContext.literalStack[depth] = true;\n        }\n        return super.validate(parsingContext, util, keys, depth, inProperty);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return await util.unaliasKeyword(keys[depth], keys.slice(0, keys.length - 1), depth - 1, true) === '@value';\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // If the value is valid, indicate that we are processing a literal.\n        // The actual value will be determined at the parent level when the @value is part of an object,\n        // because we may want to take into account additional entries such as @language.\n        // See {@link Util.valueToTerm}\n        // Indicate that we are processing a literal, and that no later predicates should be parsed at this depth.\n        parsingContext.literalStack[depth] = true;\n        // Void any buffers that we may have accumulated up until now\n        delete parsingContext.unidentifiedValuesBuffer[depth];\n        delete parsingContext.unidentifiedGraphsBuffer[depth];\n        // Indicate that we have not emitted at this depth\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordValue = EntryHandlerKeywordValue;\n//# sourceMappingURL=EntryHandlerKeywordValue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/JsonLdParser\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerArrayValue = void 0;\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of an array.\n */\nclass EntryHandlerArrayValue {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return this.test(parsingContext, util, null, keys, depth);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return typeof keys[depth] === 'number';\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        let parentKey = await util.unaliasKeywordParent(keys, depth);\n        // Check if we have an anonymous list\n        if (parentKey === '@list') {\n            // Our value is part of an array\n            // Determine the list root key\n            let listRootKey = null;\n            let listRootDepth = 0;\n            for (let i = depth - 2; i > 0; i--) {\n                const keyOption = keys[i];\n                if (typeof keyOption === 'string' || typeof keyOption === 'number') {\n                    listRootDepth = i;\n                    listRootKey = keyOption;\n                    break;\n                }\n            }\n            if (listRootKey !== null) {\n                // Emit the given objects as list elements\n                const values = await util.valueToTerm(await parsingContext.getContext(keys), listRootKey, value, depth, keys);\n                for (const object of values) {\n                    await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n                }\n                // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n                if (values.length === 0) {\n                    await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n                }\n            }\n        }\n        else if (parentKey === '@set') {\n            // Our value is part of a set, so we just add it to the parent-parent\n            await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);\n        }\n        else if (parentKey !== undefined && parentKey !== '@type') {\n            // Buffer our value using the parent key as predicate\n            // Determine the first parent key that is *not* an array key\n            // This is needed in case we have an @list container with nested arrays,\n            // where each of them should produce nested RDF lists.\n            for (let i = depth - 1; i > 0; i--) {\n                if (typeof keys[i] !== 'number') {\n                    parentKey = await util.unaliasKeyword(keys[i], keys, i);\n                    break;\n                }\n            }\n            // Check if the predicate is marked as an @list in the context\n            const parentContext = await parsingContext.getContext(keys.slice(0, -1));\n            if ('@list' in Util_1.Util.getContextValueContainer(parentContext, parentKey)) {\n                // Our value is part of an array\n                // Emit the given objects as list elements\n                parsingContext.emittedStack[depth + 1] = true; // Ensure the creation of bnodes for empty nodes\n                const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);\n                for (const object of values) {\n                    await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, -1), depth - 1);\n                }\n                // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n                if (values.length === 0) {\n                    await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);\n                }\n            }\n            else {\n                // Copy the stack values up one level so that the next job can access them.\n                parsingContext.shiftStack(depth, 1);\n                // Execute the job one level higher\n                await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false);\n                // Remove any defined contexts at this level to avoid it to propagate to the next array element.\n                parsingContext.contextTree.removeContext(keys.slice(0, -1));\n            }\n        }\n    }\n    async handleListElement(parsingContext, util, value, valueOriginal, depth, listRootKeys, listRootDepth) {\n        // Buffer our value as an RDF list using the listRootKey as predicate\n        let listPointer = parsingContext.listPointerStack[depth];\n        if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))['@value'] !== null) {\n            if (!listPointer || !listPointer.value) {\n                const linkTerm = util.dataFactory.blankNode();\n                listPointer = { value: linkTerm, listRootDepth, listId: linkTerm };\n            }\n            else {\n                // rdf:rest links are always emitted before the next element,\n                // as the blank node identifier is only created at that point.\n                // Because of this reason, the final rdf:nil is emitted when the stack depth is decreased.\n                const newLinkTerm = util.dataFactory.blankNode();\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm, util.getDefaultGraph()));\n                // Update the list pointer for the next element\n                listPointer.value = newLinkTerm;\n            }\n            // Emit a list element for the current value\n            // Omit rdf:first if the value is invalid\n            if (value) {\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfFirst, value, util.getDefaultGraph()));\n            }\n        }\n        else {\n            // A falsy list element if found.\n            // Mark it as an rdf:nil list until another valid list element comes in\n            if (!listPointer) {\n                listPointer = { listRootDepth, listId: util.rdfNil };\n            }\n        }\n        parsingContext.listPointerStack[depth] = listPointer;\n    }\n}\nexports.EntryHandlerArrayValue = EntryHandlerArrayValue;\n//# sourceMappingURL=EntryHandlerArrayValue.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/ContextParser\"), exports);\n__exportStar(require(\"./lib/ErrorCoded\"), exports);\n__exportStar(require(\"./lib/FetchDocumentLoader\"), exports);\n__exportStar(require(\"./lib/IDocumentLoader\"), exports);\n__exportStar(require(\"./lib/JsonLdContext\"), exports);\n__exportStar(require(\"./lib/JsonLdContextNormalized\"), exports);\n__exportStar(require(\"./lib/Util\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\n// tslint:disable:max-line-length\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=JsonLdContext.js.map","class Variable {\n  constructor (name) {\n    this.value = name\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value\n  }\n}\n\nVariable.prototype.termType = 'Variable'\n\nmodule.exports = Variable\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerType = void 0;\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @type.\n *\n * This will add this entry to the parent node, and use the current key as an rdf:type value.\n */\nclass ContainerHandlerType {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        if (!Array.isArray(value)) {\n            if (typeof value === 'string') {\n                // Determine the @type of the container\n                const context = await parsingContext.getContext(keys);\n                const containerTypeType = Util_1.Util.getContextValueType(context, keys[depth - 1]);\n                // String values refer to node references\n                const id = containerTypeType === '@vocab'\n                    ? await util.createVocabOrBaseTerm(context, value)\n                    : await util.resourceToTerm(context, value);\n                if (id) {\n                    // Handle the value of this node as @id, which will also cause the predicate from above to be emitted.\n                    const subValue = { '@id': id.termType === 'NamedNode' ? id.value : value };\n                    await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true);\n                    // Set the id in the stack so it can be used for the rdf:type handling later on\n                    parsingContext.idStack[depth + 1] = [id];\n                }\n            }\n            else {\n                // Other values are handled by handling them as a proper job\n                // Check needed for cases where entries don't have an explicit @id\n                const entryHasIdentifier = !!parsingContext.idStack[depth + 1];\n                // Handle the value of this node, which will also cause the predicate from above to be emitted.\n                if (!entryHasIdentifier) {\n                    delete parsingContext.idStack[depth]; // Force new (blank node) identifier\n                }\n                await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n                if (!entryHasIdentifier) {\n                    parsingContext.idStack[depth + 1] = parsingContext.idStack[depth]; // Copy the id to the child node, for @type\n                }\n            }\n            // Identify the type to emit.\n            const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);\n            const type = keyOriginal !== null\n                ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal)\n                : null;\n            if (type) {\n                // Push the type to the stack using the rdf:type predicate\n                await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, util.rdfType, type, false);\n            }\n            // Flush any pending flush buffers\n            await parsingContext.handlePendingContainerFlushBuffers();\n        }\n        parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n    }\n}\nexports.ContainerHandlerType = ContainerHandlerType;\n//# sourceMappingURL=ContainerHandlerType.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","const NamedNode = require('./NamedNode.js')\n\nclass Literal {\n  constructor (value, language, datatype) {\n    this.value = value\n    this.datatype = Literal.stringDatatype\n    this.language = ''\n\n    if (language) {\n      this.language = language\n      this.datatype = Literal.langStringDatatype\n    } else if (datatype) {\n      this.datatype = datatype\n    }\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value &&\n      other.language === this.language && other.datatype.equals(this.datatype)\n  }\n}\n\nLiteral.prototype.termType = 'Literal'\n\nLiteral.langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')\nLiteral.stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')\n\nmodule.exports = Literal\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonLdParser = void 0;\n// tslint:disable-next-line:no-var-requires\nconst Parser = require('jsonparse');\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst stream_1 = require(\"stream\");\nconst EntryHandlerArrayValue_1 = require(\"./entryhandler/EntryHandlerArrayValue\");\nconst EntryHandlerContainer_1 = require(\"./entryhandler/EntryHandlerContainer\");\nconst EntryHandlerInvalidFallback_1 = require(\"./entryhandler/EntryHandlerInvalidFallback\");\nconst EntryHandlerPredicate_1 = require(\"./entryhandler/EntryHandlerPredicate\");\nconst EntryHandlerKeywordContext_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordContext\");\nconst EntryHandlerKeywordGraph_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordGraph\");\nconst EntryHandlerKeywordId_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordId\");\nconst EntryHandlerKeywordIncluded_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordIncluded\");\nconst EntryHandlerKeywordNest_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordNest\");\nconst EntryHandlerKeywordType_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordType\");\nconst EntryHandlerKeywordUnknownFallback_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordUnknownFallback\");\nconst EntryHandlerKeywordValue_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordValue\");\nconst ParsingContext_1 = require(\"./ParsingContext\");\nconst Util_1 = require(\"./Util\");\nconst http_link_header_1 = require(\"http-link-header\");\n/**\n * A stream transformer that parses JSON-LD (text) streams to an {@link RDF.Stream}.\n */\nclass JsonLdParser extends stream_1.Transform {\n    constructor(options) {\n        super({ readableObjectMode: true });\n        options = options || {};\n        this.options = options;\n        this.parsingContext = new ParsingContext_1.ParsingContext(Object.assign({ parser: this }, options));\n        this.util = new Util_1.Util({ dataFactory: options.dataFactory, parsingContext: this.parsingContext });\n        this.jsonParser = new Parser();\n        this.contextJobs = [];\n        this.typeJobs = [];\n        this.contextAwaitingJobs = [];\n        this.lastDepth = 0;\n        this.lastKeys = [];\n        this.lastOnValueJob = Promise.resolve();\n        this.attachJsonParserListeners();\n        this.on('end', () => {\n            if (typeof this.jsonParser.mode !== 'undefined') {\n                this.emit('error', new Error('Unclosed document'));\n            }\n        });\n    }\n    /**\n     * Construct a JsonLdParser from the given HTTP response.\n     *\n     * This will throw an error if no valid JSON response is received\n     * (application/ld+json, application/json, or something+json).\n     *\n     * For raw JSON responses, exactly one link header pointing to a JSON-LD context is required.\n     *\n     * This method is not responsible for handling redirects.\n     *\n     * @param baseIRI The URI of the received response.\n     * @param mediaType The received content type.\n     * @param headers Optional HTTP headers.\n     * @param options Optional parser options.\n     */\n    static fromHttpResponse(baseIRI, mediaType, headers, options) {\n        let context;\n        // Special cases when receiving something else than the JSON-LD media type\n        if (mediaType !== 'application/ld+json') {\n            // Only accept JSON or JSON extension types\n            if (mediaType !== 'application/json' && !mediaType.endsWith('+json')) {\n                throw new jsonld_context_parser_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n            // We need exactly one JSON-LD context in the link header\n            if (headers && headers.has('Link')) {\n                headers.forEach((value, key) => {\n                    if (key === 'link') {\n                        const linkHeader = http_link_header_1.parse(value);\n                        for (const link of linkHeader.get('rel', 'http://www.w3.org/ns/json-ld#context')) {\n                            if (context) {\n                                throw new jsonld_context_parser_1.ErrorCoded('Multiple JSON-LD context link headers were found on ' + baseIRI, jsonld_context_parser_1.ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);\n                            }\n                            context = link.uri;\n                        }\n                    }\n                });\n            }\n            if (!context && !(options === null || options === void 0 ? void 0 : options.ignoreMissingContextLinkHeader)) {\n                throw new jsonld_context_parser_1.ErrorCoded(`Missing context link header for media type ${mediaType} on ${baseIRI}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        // Check if the streaming profile is present\n        let streamingProfile;\n        if (headers && headers.has('Content-Type')) {\n            const contentType = headers.get('Content-Type');\n            const match = /; *profile=([^\"]*)/.exec(contentType);\n            if (match && match[1] === 'http://www.w3.org/ns/json-ld#streaming') {\n                streamingProfile = true;\n            }\n        }\n        return new JsonLdParser(Object.assign({ baseIRI,\n            context,\n            streamingProfile }, options ? options : {}));\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new JsonLdParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        this.jsonParser.write(chunk);\n        this.lastOnValueJob\n            .then(() => callback(), (error) => callback(error));\n    }\n    /**\n     * Start a new job for parsing the given value.\n     *\n     * This will let the first valid {@link IEntryHandler} handle the entry.\n     *\n     * @param {any[]} keys The stack of keys.\n     * @param value The value to parse.\n     * @param {number} depth The depth to parse at.\n     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n     * @return {Promise<void>} A promise resolving when the job is done.\n     */\n    async newOnValueJob(keys, value, depth, lastDepthCheck) {\n        let flushStacks = true;\n        // When we go up the stack, emit all unidentified values\n        // We need to do this before the new job, because the new job may require determined values from the flushed jobs.\n        if (lastDepthCheck && depth < this.lastDepth) {\n            // Check if we had any RDF lists that need to be terminated with an rdf:nil\n            const listPointer = this.parsingContext.listPointerStack[this.lastDepth];\n            if (listPointer) {\n                // Terminate the list if the had at least one value\n                if (listPointer.value) {\n                    this.emit('data', this.util.dataFactory.quad(listPointer.value, this.util.rdfRest, this.util.rdfNil, this.util.getDefaultGraph()));\n                }\n                // Add the list id to the id stack, so it can be used higher up in the stack\n                listPointer.listId.listHead = true;\n                this.parsingContext.idStack[listPointer.listRootDepth + 1] = [listPointer.listId];\n                this.parsingContext.listPointerStack.splice(this.lastDepth, 1);\n            }\n            // Flush the buffer for lastDepth\n            // If the parent key is a special type of container, postpone flushing until that parent is handled.\n            if (await EntryHandlerContainer_1.EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth)) {\n                this.parsingContext.pendingContainerFlushBuffers\n                    .push({ depth: this.lastDepth, keys: this.lastKeys.slice(0, this.lastKeys.length) });\n                flushStacks = false;\n            }\n            else {\n                await this.flushBuffer(this.lastDepth, this.lastKeys);\n            }\n        }\n        const key = await this.util.unaliasKeyword(keys[depth], keys, depth);\n        const parentKey = await this.util.unaliasKeywordParent(keys, depth);\n        this.parsingContext.emittedStack[depth] = true;\n        let handleKey = true;\n        // Keywords inside @reverse is not allowed apart from @context\n        if (jsonld_context_parser_1.Util.isValidKeyword(key) && parentKey === '@reverse' && key !== '@context') {\n            this.emit('error', new jsonld_context_parser_1.ErrorCoded(`Found the @id '${value}' inside an @reverse property`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));\n        }\n        // Skip further processing if one of the parent nodes are invalid.\n        // We use the validationStack to reuse validation results that were produced before with common key stacks.\n        let inProperty = false;\n        if (this.parsingContext.validationStack.length > 1) {\n            inProperty = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property;\n        }\n        for (let i = Math.max(1, this.parsingContext.validationStack.length - 1); i < keys.length - 1; i++) {\n            const validationResult = this.parsingContext.validationStack[i]\n                || (this.parsingContext.validationStack[i] = await this.validateKey(keys.slice(0, i + 1), i, inProperty));\n            if (!validationResult.valid) {\n                this.parsingContext.emittedStack[depth] = false;\n                handleKey = false;\n                break;\n            }\n            else if (!inProperty && validationResult.property) {\n                inProperty = true;\n            }\n        }\n        // Skip further processing if this node is part of a literal\n        if (this.util.isLiteral(depth)) {\n            handleKey = false;\n        }\n        // Get handler\n        if (handleKey) {\n            for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {\n                const testResult = await entryHandler.test(this.parsingContext, this.util, key, keys, depth);\n                if (testResult) {\n                    // Pass processing over to the handler\n                    await entryHandler.handle(this.parsingContext, this.util, key, keys, value, depth, testResult);\n                    // Flag that this depth is processed\n                    if (entryHandler.isStackProcessor()) {\n                        this.parsingContext.processingStack[depth] = true;\n                    }\n                    break;\n                }\n            }\n        }\n        // Validate value indexes on the root.\n        if (depth === 0 && Array.isArray(value)) {\n            await this.util.validateValueIndexes(value);\n        }\n        // When we go up the stack, flush the old stack\n        if (flushStacks && depth < this.lastDepth) {\n            // Reset our stacks\n            this.flushStacks(this.lastDepth);\n        }\n        this.lastDepth = depth;\n        this.lastKeys = keys;\n        // Clear the keyword cache at this depth, and everything underneath.\n        this.parsingContext.unaliasedKeywordCacheStack.splice(depth - 1);\n    }\n    /**\n     * Flush the processing stacks at the given depth.\n     * @param {number} depth A depth.\n     */\n    flushStacks(depth) {\n        this.parsingContext.processingStack.splice(depth, 1);\n        this.parsingContext.processingType.splice(depth, 1);\n        this.parsingContext.emittedStack.splice(depth, 1);\n        this.parsingContext.idStack.splice(depth, 1);\n        this.parsingContext.graphStack.splice(depth + 1, 1);\n        this.parsingContext.graphContainerTermStack.splice(depth, 1);\n        this.parsingContext.jsonLiteralStack.splice(depth, 1);\n        this.parsingContext.validationStack.splice(depth - 1, 2);\n        this.parsingContext.literalStack.splice(depth, this.parsingContext.literalStack.length - depth);\n        // TODO: just like the literal stack, splice all other stack until the end as well?\n    }\n    /**\n     * Flush buffers for the given depth.\n     *\n     * This should be called after the last entry at a given depth was processed.\n     *\n     * @param {number} depth A depth.\n     * @param {any[]} keys A stack of keys.\n     * @return {Promise<void>} A promise resolving if flushing is done.\n     */\n    async flushBuffer(depth, keys) {\n        let subjects = this.parsingContext.idStack[depth];\n        if (!subjects) {\n            subjects = this.parsingContext.idStack[depth] = [this.util.dataFactory.blankNode()];\n        }\n        // Flush values at this level\n        const valueBuffer = this.parsingContext.unidentifiedValuesBuffer[depth];\n        if (valueBuffer) {\n            for (const subject of subjects) {\n                const depthOffsetGraph = await this.util.getDepthOffsetGraph(depth, keys);\n                const graphs = (this.parsingContext.graphStack[depth] || depthOffsetGraph >= 0)\n                    ? this.parsingContext.idStack[depth - depthOffsetGraph - 1]\n                    : [await this.util.getGraphContainerValue(keys, depth)];\n                if (graphs) {\n                    for (const graph of graphs) {\n                        // Flush values to stream if the graph @id is known\n                        this.parsingContext.emittedStack[depth] = true;\n                        for (const bufferedValue of valueBuffer) {\n                            if (bufferedValue.reverse) {\n                                this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(bufferedValue.object, bufferedValue.predicate, subject, graph));\n                            }\n                            else {\n                                this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(subject, bufferedValue.predicate, bufferedValue.object, graph));\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Place the values in the graphs buffer if the graph @id is not yet known\n                    const subGraphBuffer = this.parsingContext.getUnidentifiedGraphBufferSafe(depth - await this.util.getDepthOffsetGraph(depth, keys) - 1);\n                    for (const bufferedValue of valueBuffer) {\n                        if (bufferedValue.reverse) {\n                            subGraphBuffer.push({\n                                object: subject,\n                                predicate: bufferedValue.predicate,\n                                subject: bufferedValue.object,\n                            });\n                        }\n                        else {\n                            subGraphBuffer.push({\n                                object: bufferedValue.object,\n                                predicate: bufferedValue.predicate,\n                                subject,\n                            });\n                        }\n                    }\n                }\n            }\n            this.parsingContext.unidentifiedValuesBuffer.splice(depth, 1);\n            this.parsingContext.literalStack.splice(depth, 1);\n            this.parsingContext.jsonLiteralStack.splice(depth, 1);\n        }\n        // Flush graphs at this level\n        const graphBuffer = this.parsingContext.unidentifiedGraphsBuffer[depth];\n        if (graphBuffer) {\n            for (const subject of subjects) {\n                // A @graph statement at the root without @id relates to the default graph,\n                // unless there are top-level properties,\n                // others relate to blank nodes.\n                const graph = depth === 1 && subject.termType === 'BlankNode'\n                    && !this.parsingContext.topLevelProperties ? this.util.getDefaultGraph() : subject;\n                this.parsingContext.emittedStack[depth] = true;\n                for (const bufferedValue of graphBuffer) {\n                    this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(bufferedValue.subject, bufferedValue.predicate, bufferedValue.object, graph));\n                }\n            }\n            this.parsingContext.unidentifiedGraphsBuffer.splice(depth, 1);\n        }\n    }\n    /**\n     * Check if at least one {@link IEntryHandler} validates the entry to true.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth A depth.\n     * @param {boolean} inProperty If the current depth is part of a valid property node.\n     * @return {Promise<{ valid: boolean, property: boolean }>} A promise resolving to true or false.\n     */\n    async validateKey(keys, depth, inProperty) {\n        for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {\n            if (await entryHandler.validate(this.parsingContext, this.util, keys, depth, inProperty)) {\n                return { valid: true, property: inProperty || entryHandler.isPropertyHandler() };\n            }\n        }\n        return { valid: false, property: false };\n    }\n    /**\n     * Attach all required listeners to the JSON parser.\n     *\n     * This should only be called once.\n     */\n    attachJsonParserListeners() {\n        // Listen to json parser events\n        this.jsonParser.onValue = (value) => {\n            const depth = this.jsonParser.stack.length;\n            const keys = (new Array(depth + 1).fill(0)).map((v, i) => {\n                return i === depth ? this.jsonParser.key : this.jsonParser.stack[i].key;\n            });\n            if (!this.isParsingContextInner(depth)) { // Don't parse inner nodes inside @context\n                const valueJobCb = () => this.newOnValueJob(keys, value, depth, true);\n                if (!this.parsingContext.streamingProfile\n                    && !this.parsingContext.contextTree.getContext(keys.slice(0, -1))) {\n                    // If an out-of-order context is allowed,\n                    // we have to buffer everything.\n                    // We store jobs for @context's and @type's separately,\n                    // because at the end, we have to process them first.\n                    // We also handle @type because these *could* introduce a type-scoped context.\n                    if (keys[depth] === '@context') {\n                        let jobs = this.contextJobs[depth];\n                        if (!jobs) {\n                            jobs = this.contextJobs[depth] = [];\n                        }\n                        jobs.push(valueJobCb);\n                    }\n                    else if (keys[depth] === '@type'\n                        || typeof keys[depth] === 'number' && keys[depth - 1] === '@type') { // Also capture @type with array values\n                        // Remove @type from keys, because we want it to apply to parent later on\n                        this.typeJobs.push({ job: valueJobCb, keys: keys.slice(0, keys.length - 1) });\n                    }\n                    else {\n                        this.contextAwaitingJobs.push({ job: valueJobCb, keys });\n                    }\n                }\n                else {\n                    // Make sure that our value jobs are chained synchronously\n                    this.lastOnValueJob = this.lastOnValueJob.then(valueJobCb);\n                }\n                // Execute all buffered jobs on deeper levels\n                if (!this.parsingContext.streamingProfile && depth === 0) {\n                    this.lastOnValueJob = this.lastOnValueJob\n                        .then(() => this.executeBufferedJobs());\n                }\n            }\n        };\n        this.jsonParser.onError = (error) => {\n            this.emit('error', error);\n        };\n    }\n    /**\n     * Check if the parser is currently parsing an element that is part of an @context entry.\n     * @param {number} depth A depth.\n     * @return {boolean} A boolean.\n     */\n    isParsingContextInner(depth) {\n        for (let i = depth; i > 0; i--) {\n            if (this.jsonParser.stack[i - 1].key === '@context') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Execute all buffered jobs.\n     * @return {Promise<void>} A promise resolving if all jobs are finished.\n     */\n    async executeBufferedJobs() {\n        // Handle context jobs\n        for (const jobs of this.contextJobs) {\n            if (jobs) {\n                for (const job of jobs) {\n                    await job();\n                }\n            }\n        }\n        // Clear the keyword cache.\n        this.parsingContext.unaliasedKeywordCacheStack.splice(0);\n        // Handle non-context jobs\n        for (const job of this.contextAwaitingJobs) {\n            // Check if we have a type (with possible type-scoped context) that should be handled before.\n            // We check all possible parent nodes for the current job, from root to leaves.\n            if (this.typeJobs.length > 0) {\n                // First collect all applicable type jobs\n                const applicableTypeJobs = [];\n                const applicableTypeJobIds = [];\n                for (let i = 0; i < this.typeJobs.length; i++) {\n                    const typeJob = this.typeJobs[i];\n                    if (Util_1.Util.isPrefixArray(typeJob.keys, job.keys)) {\n                        applicableTypeJobs.push(typeJob);\n                        applicableTypeJobIds.push(i);\n                    }\n                }\n                // Next, sort the jobs from short to long key length (to ensure types higher up in the tree to be handled first)\n                const sortedTypeJobs = applicableTypeJobs.sort((job1, job2) => job1.keys.length - job2.keys.length);\n                // Finally, execute the jobs in order\n                for (const typeJob of sortedTypeJobs) {\n                    await typeJob.job();\n                }\n                // Remove the executed type jobs\n                // Sort first, so we can efficiently splice\n                const sortedApplicableTypeJobIds = applicableTypeJobIds.sort().reverse();\n                for (const jobId of sortedApplicableTypeJobIds) {\n                    this.typeJobs.splice(jobId, 1);\n                }\n            }\n            await job.job();\n        }\n    }\n}\nexports.JsonLdParser = JsonLdParser;\nJsonLdParser.DEFAULT_PROCESSING_MODE = '1.1';\nJsonLdParser.ENTRY_HANDLERS = [\n    new EntryHandlerArrayValue_1.EntryHandlerArrayValue(),\n    new EntryHandlerKeywordContext_1.EntryHandlerKeywordContext(),\n    new EntryHandlerKeywordId_1.EntryHandlerKeywordId(),\n    new EntryHandlerKeywordIncluded_1.EntryHandlerKeywordIncluded(),\n    new EntryHandlerKeywordGraph_1.EntryHandlerKeywordGraph(),\n    new EntryHandlerKeywordNest_1.EntryHandlerKeywordNest(),\n    new EntryHandlerKeywordType_1.EntryHandlerKeywordType(),\n    new EntryHandlerKeywordValue_1.EntryHandlerKeywordValue(),\n    new EntryHandlerContainer_1.EntryHandlerContainer(),\n    new EntryHandlerKeywordUnknownFallback_1.EntryHandlerKeywordUnknownFallback(),\n    new EntryHandlerPredicate_1.EntryHandlerPredicate(),\n    new EntryHandlerInvalidFallback_1.EntryHandlerInvalidFallback(),\n];\n//# sourceMappingURL=JsonLdParser.js.map","/*global Buffer*/\n// Named constants with unique integer values\nvar C = {};\n// Tokens\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON         = C.COLON         = 0x5;\nvar COMMA         = C.COMMA         = 0x6;\nvar TRUE          = C.TRUE          = 0x7;\nvar FALSE         = C.FALSE         = 0x8;\nvar NULL          = C.NULL          = 0x9;\nvar STRING        = C.STRING        = 0xa;\nvar NUMBER        = C.NUMBER        = 0xb;\n// Tokenizer States\nvar START   = C.START   = 0x11;\nvar STOP    = C.STOP    = 0x12;\nvar TRUE1   = C.TRUE1   = 0x21;\nvar TRUE2   = C.TRUE2   = 0x22;\nvar TRUE3   = C.TRUE3   = 0x23;\nvar FALSE1  = C.FALSE1  = 0x31;\nvar FALSE2  = C.FALSE2  = 0x32;\nvar FALSE3  = C.FALSE3  = 0x33;\nvar FALSE4  = C.FALSE4  = 0x34;\nvar NULL1   = C.NULL1   = 0x41;\nvar NULL2   = C.NULL2   = 0x42;\nvar NULL3   = C.NULL3   = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66;\n// Parser States\nvar VALUE   = C.VALUE   = 0x71;\nvar KEY     = C.KEY     = 0x72;\n// Parser Modes\nvar OBJECT  = C.OBJECT  = 0x81;\nvar ARRAY   = C.ARRAY   = 0x82;\n// Character constants\nvar BACK_SLASH =      \"\\\\\".charCodeAt(0);\nvar FORWARD_SLASH =   \"\\/\".charCodeAt(0);\nvar BACKSPACE =       \"\\b\".charCodeAt(0);\nvar FORM_FEED =       \"\\f\".charCodeAt(0);\nvar NEWLINE =         \"\\n\".charCodeAt(0);\nvar CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nvar TAB =             \"\\t\".charCodeAt(0);\n\nvar STRING_BUFFER_SIZE = 64 * 1024;\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n\n  this.string = undefined; // string data\n  this.stringBuffer = Buffer.alloc ? Buffer.alloc(STRING_BUFFER_SIZE) : new Buffer(STRING_BUFFER_SIZE);\n  this.stringBufferOffset = 0;\n  this.unicode = undefined; // unicode escapes\n  this.highSurrogate = undefined;\n\n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n\n  // Stream offset\n  this.offset = -1;\n}\n\n// Slow code to string converter (only used when throwing syntax errors)\nParser.toknam = function (code) {\n  var keys = Object.keys(C);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (C[key] === code) { return key; }\n  }\n  return code && (\"0x\" + code.toString(16));\n};\n\nvar proto = Parser.prototype;\nproto.onError = function (err) { throw err; };\nproto.charError = function (buffer, i) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n};\nproto.appendStringChar = function (char) {\n  if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8');\n    this.stringBufferOffset = 0;\n  }\n\n  this.stringBuffer[this.stringBufferOffset++] = char;\n};\nproto.appendStringBuf = function (buf, start, end) {\n  var size = buf.length;\n  if (typeof start === 'number') {\n    if (typeof end === 'number') {\n      if (end < 0) {\n        // adding a negative end decreeses the size\n        size = buf.length - start + end;\n      } else {\n        size = end - start;\n      }\n    } else {\n      size = buf.length - start;\n    }\n  }\n\n  if (size < 0) {\n    size = 0;\n  }\n\n  if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n    this.stringBufferOffset = 0;\n  }\n\n  buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);\n  this.stringBufferOffset += size;\n};\nproto.write = function (buffer) {\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);\n  var n;\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    if (this.tState === START){\n      n = buffer[i];\n      this.offset++;\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,\n      }else if(n === 0x74){ this.tState = TRUE1;  // t\n      }else if(n === 0x66){ this.tState = FALSE1;  // f\n      }else if(n === 0x6e){ this.tState = NULL1; // n\n      }else if(n === 0x22){ // \"\n        this.string = \"\";\n        this.stringBufferOffset = 0;\n        this.tState = STRING1;\n      }else if(n === 0x2d){ this.string = \"-\"; this.tState = NUMBER1; // -\n      }else{\n        if (n >= 0x30 && n < 0x40) { // 1-9\n          this.string = String.fromCharCode(n); this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {\n          // whitespace\n        } else {\n          return this.charError(buffer, i);\n        }\n      }\n    }else if (this.tState === STRING1){ // After open quote\n      n = buffer[i]; // get current byte from buffer\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];\n        }\n\n        this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n        i = i + j - 1;\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if (n <= 193 || n > 244) {\n          return this.onError(new Error(\"Invalid UTF-8 character at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n        }\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;\n          i = buffer.length - 1;\n        } else {\n          this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);\n          i = i + this.bytes_in_sequence - 1;\n        }\n      } else if (n === 0x22) {\n        this.tState = START;\n        this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n        this.stringBufferOffset = 0;\n        this.onToken(STRING, this.string);\n        this.offset += Buffer.byteLength(this.string, 'utf8') + 1;\n        this.string = undefined;\n      }\n      else if (n === 0x5c) {\n        this.tState = STRING2;\n      }\n      else if (n >= 0x20) { this.appendStringChar(n); }\n      else {\n          return this.charError(buffer, i);\n      }\n    }else if (this.tState === STRING2){ // After backslash\n      n = buffer[i];\n      if(n === 0x22){ this.appendStringChar(n); this.tState = STRING1;\n      }else if(n === 0x5c){ this.appendStringChar(BACK_SLASH); this.tState = STRING1;\n      }else if(n === 0x2f){ this.appendStringChar(FORWARD_SLASH); this.tState = STRING1;\n      }else if(n === 0x62){ this.appendStringChar(BACKSPACE); this.tState = STRING1;\n      }else if(n === 0x66){ this.appendStringChar(FORM_FEED); this.tState = STRING1;\n      }else if(n === 0x6e){ this.appendStringChar(NEWLINE); this.tState = STRING1;\n      }else if(n === 0x72){ this.appendStringChar(CARRIAGE_RETURN); this.tState = STRING1;\n      }else if(n === 0x74){ this.appendStringChar(TAB); this.tState = STRING1;\n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;\n      }else{\n        return this.charError(buffer, i);\n      }\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];\n      // 0-9 A-F a-f\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {\n        this.unicode += String.fromCharCode(n);\n        if (this.tState++ === STRING6) {\n          var intVal = parseInt(this.unicode, 16);\n          this.unicode = undefined;\n          if (this.highSurrogate !== undefined && intVal >= 0xDC00 && intVal < (0xDFFF + 1)) { //<56320,57343> - lowSurrogate\n            this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal)));\n            this.highSurrogate = undefined;\n          } else if (this.highSurrogate === undefined && intVal >= 0xD800 && intVal < (0xDBFF + 1)) { //<55296,56319> - highSurrogate\n            this.highSurrogate = intVal;\n          } else {\n            if (this.highSurrogate !== undefined) {\n              this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate)));\n              this.highSurrogate = undefined;\n            }\n            this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));\n          }\n          this.tState = STRING1;\n        }\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {\n        n = buffer[i];\n\n        switch (n) {\n          case 0x30: // 0\n          case 0x31: // 1\n          case 0x32: // 2\n          case 0x33: // 3\n          case 0x34: // 4\n          case 0x35: // 5\n          case 0x36: // 6\n          case 0x37: // 7\n          case 0x38: // 8\n          case 0x39: // 9\n          case 0x2e: // .\n          case 0x65: // e\n          case 0x45: // E\n          case 0x2b: // +\n          case 0x2d: // -\n            this.string += String.fromCharCode(n);\n            this.tState = NUMBER3;\n            break;\n          default:\n            this.tState = START;\n            var result = Number(this.string);\n\n            if (isNaN(result)){\n              return this.charError(buffer, i);\n            }\n\n            if ((this.string.match(/[0-9]+/) == this.string) && (result.toString() != this.string)) {\n              // Long string of digits which is an ID string and not valid and/or safe JavaScript integer Number\n              this.onToken(STRING, this.string);\n            } else {\n              this.onToken(NUMBER, result);\n            }\n\n            this.offset += this.string.length - 1;\n            this.string = undefined;\n            i--;\n            break;\n        }\n    }else if (this.tState === TRUE1){ // r\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === TRUE2){ // u\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === TRUE3){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); this.offset+= 3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE1){ // a\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE2){ // l\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE3){ // s\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE4){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); this.offset+= 4; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL1){ // u\n      if (buffer[i] === 0x75) { this.tState = NULL2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL2){ // l\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL3){ // l\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); this.offset += 3; }\n      else { return this.charError(buffer, i); }\n    }\n  }\n};\nproto.onToken = function (token, value) {\n  // Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + Parser.toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + Parser.toknam(this.state)));\n};\nproto.push = function () {\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});\n};\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n  if (!this.mode) { this.state = VALUE; }\n};\nproto.emit = function (value) {\n  if (this.mode) { this.state = COMMA; }\n  this.onValue(value);\n};\nproto.onValue = function (value) {\n  // Override me\n};\nproto.onToken = function (token, value) {\n  if(this.state === VALUE){\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n      this.emit(value);\n    }else if(token === LEFT_BRACE){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n    }else if(token === LEFT_BRACKET){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n    }else if(token === RIGHT_BRACE){\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    }else if(token === RIGHT_BRACKET){\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    }else{\n      return this.parseError(token, value);\n    }\n  }else if(this.state === KEY){\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  }else if(this.state === COLON){\n    if (token === COLON) { this.state = VALUE; }\n    else { return this.parseError(token, value); }\n  }else if(this.state === COMMA){\n    if (token === COMMA) {\n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }\n      else if (this.mode === OBJECT) { this.state = KEY; }\n\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  }else{\n    return this.parseError(token, value);\n  }\n};\n\nParser.C = C;\n\nmodule.exports = Parser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordGraph = void 0;\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @graph entries.\n */\nclass EntryHandlerKeywordGraph extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@graph');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // The current identifier identifies a graph for the deeper level.\n        parsingContext.graphStack[depth + 1] = true;\n    }\n}\nexports.EntryHandlerKeywordGraph = EntryHandlerKeywordGraph;\n//# sourceMappingURL=EntryHandlerKeywordGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchDocumentLoader = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst http_link_header_1 = require(\"http-link-header\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    constructor(fetcher) {\n        this.fetcher = fetcher;\n    }\n    async load(url) {\n        const response = await (this.fetcher || fetch)(url, { headers: new Headers({ accept: 'application/ld+json' }) });\n        if (response.ok && response.headers) {\n            let mediaType = response.headers.get('Content-Type');\n            if (mediaType) {\n                const colonPos = mediaType.indexOf(';');\n                if (colonPos > 0) {\n                    mediaType = mediaType.substr(0, colonPos);\n                }\n            }\n            if (mediaType === 'application/ld+json') {\n                // Return JSON-LD if proper content type was returned\n                return (await response.json());\n            }\n            else {\n                // Check for alternate link for a non-JSON-LD response\n                if (response.headers.has('Link')) {\n                    let alternateUrl;\n                    response.headers.forEach((value, key) => {\n                        if (key === 'link') {\n                            const linkHeader = (0, http_link_header_1.parse)(value);\n                            for (const link of linkHeader.get('type', 'application/ld+json')) {\n                                if (link.rel === 'alternate') {\n                                    if (alternateUrl) {\n                                        throw new Error('Multiple JSON-LD alternate links were found on ' + url);\n                                    }\n                                    alternateUrl = (0, relative_to_absolute_iri_1.resolve)(link.uri, url);\n                                }\n                            }\n                        }\n                    });\n                    if (alternateUrl) {\n                        return this.load(alternateUrl);\n                    }\n                }\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        else {\n            throw new Error(response.statusText || `Status code: ${response.status}`);\n        }\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordType = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst Util_1 = require(\"../../Util\");\nconst EntryHandlerPredicate_1 = require(\"../EntryHandlerPredicate\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @graph entries.\n */\nclass EntryHandlerKeywordType extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@type');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        const keyOriginal = keys[depth];\n        // The current identifier identifies an rdf:type predicate.\n        // But we only emit it once the node closes,\n        // as it's possible that the @type is used to identify the datatype of a literal, which we ignore here.\n        const context = await parsingContext.getContext(keys);\n        const predicate = util.rdfType;\n        const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));\n        // Handle multiple values if the value is an array\n        const elements = Array.isArray(value) ? value : [value];\n        for (const element of elements) {\n            if (typeof element !== 'string') {\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @type '${element}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPE_VALUE));\n            }\n            const type = util.createVocabOrBaseTerm(context, element);\n            if (type) {\n                await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, type, reverse);\n            }\n        }\n        // Collect type-scoped contexts if they exist\n        let scopedContext = Promise.resolve(context);\n        let hasTypedScopedContext = false;\n        for (const element of elements.sort()) { // Spec requires lexicographical ordering\n            const typeContext = Util_1.Util.getContextValue(context, '@context', element, null);\n            if (typeContext) {\n                hasTypedScopedContext = true;\n                scopedContext = scopedContext.then((c) => parsingContext.parseContext(typeContext, c.getContextRaw()));\n            }\n        }\n        // Error if an out-of-order type-scoped context was found when support is not enabled.\n        if (parsingContext.streamingProfile\n            && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType)\n            && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded('Found an out-of-order type-scoped context, while streaming is enabled.' +\n                '(disable `streamingProfile`)', jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n        }\n        // If at least least one type-scoped context applies, set them in the tree.\n        if (hasTypedScopedContext) {\n            // Do not propagate by default\n            scopedContext = scopedContext.then((c) => {\n                if (!('@propagate' in c.getContextRaw())) {\n                    c.getContextRaw()['@propagate'] = false;\n                }\n                // Set the original context at this depth as a fallback\n                // This is needed when a context was already defined at the given depth,\n                // and this context needs to remain accessible from child nodes when propagation is disabled.\n                if (c.getContextRaw()['@propagate'] === false) {\n                    c.getContextRaw()['@__propagateFallback'] = context.getContextRaw();\n                }\n                return c;\n            });\n            // Set the new context in the context tree\n            parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);\n        }\n        // Flag that type has been processed at this depth\n        parsingContext.processingType[depth] = true;\n    }\n}\nexports.EntryHandlerKeywordType = EntryHandlerKeywordType;\n//# sourceMappingURL=EntryHandlerKeywordType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerLanguage = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerLanguage {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        const language = await util.getContainerKey(keys[depth], keys, depth);\n        if (Array.isArray(value)) {\n            // No type-checking needed, will be handled on each value when this handler is called recursively.\n            value = value.map((subValue) => ({ '@value': subValue, '@language': language }));\n        }\n        else {\n            if (typeof value !== 'string') {\n                throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n            }\n            value = { '@value': value, '@language': language };\n        }\n        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerLanguage = ContainerHandlerLanguage;\n//# sourceMappingURL=ContainerHandlerLanguage.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerContainer = void 0;\nconst ContainerHandlerIdentifier_1 = require(\"../containerhandler/ContainerHandlerIdentifier\");\nconst ContainerHandlerIndex_1 = require(\"../containerhandler/ContainerHandlerIndex\");\nconst ContainerHandlerLanguage_1 = require(\"../containerhandler/ContainerHandlerLanguage\");\nconst ContainerHandlerType_1 = require(\"../containerhandler/ContainerHandlerType\");\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of a container type (like @index),\n * as specified by {@link IContainerHandler}.\n */\nclass EntryHandlerContainer {\n    /**\n     * Check fit the given container is a simple @graph container.\n     * Concretely, it will check if no @index or @id is active as well.\n     * @param containers A container hash.\n     */\n    static isSimpleGraphContainer(containers) {\n        return '@graph' in containers\n            && (('@set' in containers && Object.keys(containers).length === 2) || Object.keys(containers).length === 1);\n    }\n    /**\n     * Check fit the given container is a complex @graph container.\n     * Concretely, it will check if @index or @id is active as well next to @graph.\n     * @param containers A container hash.\n     */\n    static isComplexGraphContainer(containers) {\n        return '@graph' in containers\n            && (('@set' in containers && Object.keys(containers).length > 2)\n                || (!('@set' in containers) && Object.keys(containers).length > 1));\n    }\n    /**\n     * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.\n     * @param containers The applicable containers.\n     * @param depth The container depth.\n     * @param keys The array of keys.\n     * @return The graph index.\n     */\n    static getContainerGraphIndex(containers, depth, keys) {\n        let isSimpleGraphContainer = EntryHandlerContainer.isSimpleGraphContainer(containers);\n        let index = '';\n        for (let i = depth; i < keys.length; i++) {\n            if (!isSimpleGraphContainer || typeof keys[i] === 'number') {\n                index += ':' + keys[i];\n            }\n            // Only allow a second 'real' key if in a non-simple graph container.\n            if (!isSimpleGraphContainer && typeof keys[i] !== 'number') {\n                isSimpleGraphContainer = true;\n            }\n        }\n        return index;\n    }\n    /**\n     * Return the applicable container type at the given depth.\n     *\n     * This will ignore any arrays in the key chain.\n     *\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {any[]} keys The array of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}\n     *          All applicable containers for the given depth,\n     *          the `depth` of the container root (can change when arrays are in the key chain),\n     *          and the `fallback` flag that indicates if the default container type was returned\n     *            (i.e., no dedicated container type is defined).\n     */\n    static async getContainerHandler(parsingContext, keys, depth) {\n        const fallback = {\n            containers: { '@set': true },\n            depth,\n            fallback: true,\n        };\n        // A flag that is enabled when @graph container should be tested in next iteration\n        let checkGraphContainer = false;\n        // Iterate from deeper to higher\n        const context = await parsingContext.getContext(keys, 2);\n        for (let i = depth - 1; i >= 0; i--) {\n            if (typeof keys[i] !== 'number') { // Skip array keys\n                // @graph containers without any other types are one level less deep, and require special handling\n                const containersSelf = Util_1.Util.getContextValue(context, '@container', keys[i], false);\n                if (containersSelf && EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {\n                    return {\n                        containers: containersSelf,\n                        depth: i + 1,\n                        fallback: false,\n                    };\n                }\n                const containersParent = Util_1.Util.getContextValue(context, '@container', keys[i - 1], false);\n                if (!containersParent) { // If we have the fallback container value\n                    if (checkGraphContainer) {\n                        // Return false if we were already expecting a @graph-@id of @graph-@index container\n                        return fallback;\n                    }\n                    // Check parent-parent, we may be in a @graph-@id of @graph-@index container, which have two levels\n                    checkGraphContainer = true;\n                }\n                else {\n                    // We had an invalid container next iteration, so we now have to check if we were in an @graph container\n                    const graphContainer = '@graph' in containersParent;\n                    // We're in a regular container\n                    for (const containerHandleName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n                        if (containersParent[containerHandleName]) {\n                            if (graphContainer) {\n                                // Only accept graph containers if their combined handlers can handle them.\n                                if (EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {\n                                    return {\n                                        containers: containersParent,\n                                        depth: i,\n                                        fallback: false,\n                                    };\n                                }\n                                else {\n                                    return fallback;\n                                }\n                            }\n                            else {\n                                // Only accept if we were not expecting a @graph-@id of @graph-@index container\n                                if (checkGraphContainer) {\n                                    return fallback;\n                                }\n                                else {\n                                    return {\n                                        containers: containersParent,\n                                        depth: i,\n                                        fallback: false,\n                                    };\n                                }\n                            }\n                        }\n                    }\n                    // Fail if no valid container handlers were found\n                    return fallback;\n                }\n            }\n        }\n        return fallback;\n    }\n    /**\n     * Check if we are handling a value at the given depth\n     * that is part of something that should be handled as a container,\n     * AND if this container should be buffered, so that it can be handled by a dedicated container handler.\n     *\n     * For instance, any container with @graph will NOT be buffered.\n     *\n     * This will ignore any arrays in the key chain.\n     *\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {any[]} keys The array of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<boolean>} If we are in the scope of a container handler.\n     */\n    static async isBufferableContainerHandler(parsingContext, keys, depth) {\n        const handler = await EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);\n        return !handler.fallback && !('@graph' in handler.containers);\n    }\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return !!await this.test(parsingContext, util, null, keys, depth);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        const containers = Util_1.Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);\n        for (const containerName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n            if (containers[containerName]) {\n                return {\n                    containers,\n                    handler: EntryHandlerContainer.CONTAINER_HANDLERS[containerName],\n                };\n            }\n        }\n        return null;\n    }\n    async handle(parsingContext, util, key, keys, value, depth, testResult) {\n        return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);\n    }\n}\nexports.EntryHandlerContainer = EntryHandlerContainer;\nEntryHandlerContainer.CONTAINER_HANDLERS = {\n    '@id': new ContainerHandlerIdentifier_1.ContainerHandlerIdentifier(),\n    '@index': new ContainerHandlerIndex_1.ContainerHandlerIndex(),\n    '@language': new ContainerHandlerLanguage_1.ContainerHandlerLanguage(),\n    '@type': new ContainerHandlerType_1.ContainerHandlerType(),\n};\n//# sourceMappingURL=EntryHandlerContainer.js.map","const rdf = require('@rdfjs/data-model')\nconst { JsonLdParser } = require('jsonld-streaming-parser')\nconst { Transform } = require('readable-stream')\n\nconst relativeIriProtocol = 'null:'\n\nfunction termCleanup (factory) {\n  return term => {\n    if (term.termType !== 'NamedNode') {\n      return null\n    }\n\n    if (!term.value.startsWith(relativeIriProtocol)) {\n      return null\n    }\n\n    // remove dummy protocol workaround for relative IRIs\n    return factory.namedNode(term.value.slice(relativeIriProtocol.length))\n  }\n}\n\nfunction quadCleanup (factory) {\n  const cleanup = termCleanup(factory)\n\n  return quad => {\n    const subject = cleanup(quad.subject)\n    const predicate = cleanup(quad.predicate)\n    const object = cleanup(quad.object)\n    const graph = cleanup(quad.graph)\n\n    if (subject || predicate || object || graph) {\n      return factory.quad(\n        subject || quad.subject,\n        predicate || quad.predicate,\n        object || quad.object,\n        graph || quad.graph\n      )\n    }\n\n    return quad\n  }\n}\n\nclass ParserStream {\n  constructor (input, { baseIRI = relativeIriProtocol, context = null, factory = rdf } = {}) {\n    const parser = new JsonLdParser({\n      baseIRI,\n      context,\n      dataFactory: factory,\n      streamingProfile: false\n    })\n\n    input.pipe(parser)\n\n    const cleanup = quadCleanup(factory)\n\n    const transform = new Transform({\n      objectMode: true,\n      transform: (quad, encoding, callback) => {\n        callback(null, cleanup(quad))\n      }\n    })\n\n    parser.on('context', context => {\n      Object.entries(context).forEach(([prefix, iri]) => {\n        transform.emit('prefix', prefix, factory.namedNode(iri))\n      })\n    })\n    parser.on('error', err => transform.destroy(err))\n    parser.pipe(transform)\n\n    return transform\n  }\n}\n\nmodule.exports = ParserStream\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordIncluded = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @included entries.\n */\nclass EntryHandlerKeywordIncluded extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@included');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        if (typeof value !== 'object') {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @included '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));\n        }\n        const valueUnliased = await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys));\n        if ('@value' in valueUnliased) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @value node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));\n        }\n        if ('@list' in valueUnliased) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @list node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));\n        }\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordIncluded = EntryHandlerKeywordIncluded;\n//# sourceMappingURL=EntryHandlerKeywordIncluded.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerIndex = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @index.\n *\n * This will ignore the current key and add this entry to the parent node.\n */\nclass ContainerHandlerIndex {\n    canCombineWithGraph() {\n        return true;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        if (!Array.isArray(value)) {\n            const graphContainer = '@graph' in containers;\n            // Check if the container is a property-based container by checking if there is a valid @index.\n            const context = await parsingContext.getContext(keys);\n            const indexKey = keys[depth - 1];\n            const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);\n            if (indexPropertyRaw) {\n                // Validate the @index value\n                if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {\n                    throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                if (typeof indexPropertyRaw !== 'string') {\n                    throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // When @index is used, values must be node values, unless @type: @id is defined in the context\n                if (typeof value !== 'object') {\n                    // Error if we don't have @type: @id\n                    if (Util_1.Util.getContextValueType(context, indexKey) !== '@id') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                    }\n                    // Add an @id to the stack, so our expanded @index value can make use of it\n                    const id = util.resourceToTerm(context, value);\n                    if (id) {\n                        parsingContext.idStack[depth + 1] = [id];\n                    }\n                }\n                // Expand the @index value\n                const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);\n                if (indexProperty) {\n                    const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);\n                    if (graphContainer) {\n                        // When we're in a graph container, attach the index to the graph identifier\n                        const graphId = await util.getGraphContainerValue(keys, depth + 1);\n                        for (const indexValue of indexValues) {\n                            parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));\n                        }\n                    }\n                    else {\n                        // Otherwise, attach the index to the node identifier\n                        for (const indexValue of indexValues) {\n                            await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false);\n                        }\n                    }\n                }\n            }\n            const depthOffset = graphContainer ? 2 : 1;\n            await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);\n            // Flush any pending flush buffers\n            await parsingContext.handlePendingContainerFlushBuffers();\n        }\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerIndex = ContainerHandlerIndex;\n//# sourceMappingURL=ContainerHandlerIndex.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextParser = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n        this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            let value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value = context[key] = Object.assign(Object.assign({}, value), { '@id': value['@reverse'] });\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all\n     * keys in the context will be expanded.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase, keys) {\n        const contextRaw = context.getContextRaw();\n        for (const key of (keys || Object.keys(contextRaw))) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@id': context.expandTerm(id, true) });\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@id': newId });\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            let expandedType = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === expandedType) {\n                                expandedType = context.expandTerm(type, false);\n                            }\n                            if (expandedType !== type) {\n                                changed = true;\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@type': expandedType });\n                            }\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            const lowercase = value['@language'].toLowerCase();\n                            if (lowercase !== value['@language']) {\n                                context[key] = Object.assign(Object.assign({}, value), { '@language': lowercase });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    context[key] = Object.assign(Object.assign({}, value), { '@container': { [value['@container']]: true } });\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    context[key] = Object.assign(Object.assign({}, value), { '@container': newValue });\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-level @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }, expandOptions) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key] = Object.assign(Object.assign({}, context[key]), { '@protected': true });\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                            if (Util_1.Util.isSimpleTermDefinitionPrefix(value, expandOptions)) {\n                                context[key] = Object.assign(Object.assign({}, context[key]), { '@prefix': true });\n                            }\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all\n     * keys defined in contextAfter will be checked.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions, keys) {\n        for (const key of (keys !== null && keys !== void 0 ? keys : Object.keys(contextAfter))) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    contextAfter[key] = { '@id': contextAfter[key], '@protected': true };\n                }\n                else {\n                    // We modify this deliberately,\n                    // as we need it for the value comparison (they must be identical modulo '@protected')),\n                    // and for the fact that this new value will override the first one.\n                    contextAfter[key] = Object.assign(Object.assign({}, contextAfter[key]), { '@protected': true });\n                }\n                // Error if they are not identical\n                if (!Util_1.Util.deepEqual(contextBefore[key], contextAfter[key])) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph' && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext\n            && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = (0, relative_to_absolute_iri_1.resolve)(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            try {\n                contextIri = (0, relative_to_absolute_iri_1.resolve)(contextIri, baseIRI);\n            }\n            catch (_a) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n        if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n            contextIri = 'https://schema.org/';\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all\n     * keys in the context will be iterated over.\n     */\n    async parseInnerContexts(context, options, keys) {\n        for (const key of (keys !== null && keys !== void 0 ? keys : Object.keys(context))) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n                    // Simulate a processing based on the parent context to check if there are any (potential errors).\n                    // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                    // and the final effective context may differ based on any other embedded/scoped contexts.\n                    // But hey, it's part of the spec, so we have no choice...\n                    // https://w3c.github.io/json-ld-api/#h-note-10\n                    if (this.validateContext) {\n                        try {\n                            const parentContext = Object.assign(Object.assign({}, context), { [key]: Object.assign({}, context[key]) });\n                            delete parentContext[key]['@context'];\n                            await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));\n                        }\n                        catch (e) {\n                            throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                        }\n                    }\n                    context[key] = Object.assign(Object.assign({}, value), { '@context': (await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                            .getContextRaw() });\n                }\n            }\n        }\n        return context;\n    }\n    async parse(context, options = {}, \n    // These options are only for internal use on recursive calls and should not be used by\n    // libraries consuming this function\n    internalOptions = {}) {\n        const { baseIRI, parentContext, external, processingMode = ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n        const remoteContexts = options.remoteContexts || {};\n        // Avoid remote context overflows\n        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n            throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n        }\n        if (context === null || context === undefined) {\n            // Don't allow context nullification and there are protected terms\n            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n            }\n            // Context that are explicitly set to null are empty.\n            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n        }\n        else if (typeof context === 'string') {\n            const contextIri = this.normalizeContextIri(context, baseIRI);\n            const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n            if (overriddenLoad) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n            }\n            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));\n            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n            return parsedStringContext;\n        }\n        else if (Array.isArray(context)) {\n            // As a performance consideration, first load all external contexts in parallel.\n            const contextIris = [];\n            const contexts = await Promise.all(context.map((subContext, i) => {\n                if (typeof subContext === 'string') {\n                    const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                    contextIris[i] = contextIri;\n                    const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                    if (overriddenLoad) {\n                        return overriddenLoad;\n                    }\n                    return this.load(contextIri);\n                }\n                else {\n                    return subContext;\n                }\n            }));\n            // Don't apply inheritance logic on minimal processing\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n            }\n            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                .then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }), \n            // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers\n            {\n                skipValidation: i < contexts.length - 1,\n            })), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n            // Override the base IRI if provided.\n            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n            return reducedContexts;\n        }\n        else if (typeof context === 'object') {\n            if ('@context' in context) {\n                return await this.parse(context['@context'], options);\n            }\n            // Make a deep clone of the given context, to avoid modifying it.\n            context = Object.assign({}, context);\n            // According to the JSON-LD spec, @base must be ignored from external contexts.\n            if (external) {\n                delete context['@base'];\n            }\n            // Override the base IRI if provided.\n            this.applyBaseEntry(context, options, true);\n            // Hashify container entries\n            // Do this before protected term validation as that influences term format\n            this.containersToHash(context);\n            // Don't perform any other modifications if only minimal processing is needed.\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n            }\n            // In JSON-LD 1.1, load @import'ed context prior to processing.\n            let importContext = {};\n            if ('@import' in context) {\n                if (processingMode >= 1.1) {\n                    // Only accept string values\n                    if (typeof context['@import'] !== 'string') {\n                        throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                    }\n                    // Load context\n                    importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                    delete context['@import'];\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                }\n            }\n            this.applyScopedProtected(importContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);\n            const newContext = Object.assign(importContext, context);\n            // Handle terms (before protection checks)\n            this.idifyReverseTerms(newContext);\n            this.normalize(newContext, { processingMode, normalizeLanguageTags });\n            this.applyScopedProtected(newContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);\n            const keys = Object.keys(newContext);\n            const overlappingKeys = [];\n            if (typeof parentContext === 'object') {\n                // Merge different parts of the final context in order\n                for (const key in parentContext) {\n                    if (key in newContext) {\n                        overlappingKeys.push(key);\n                    }\n                    else {\n                        newContext[key] = parentContext[key];\n                    }\n                }\n            }\n            // Parse inner contexts with minimal processing\n            await this.parseInnerContexts(newContext, options, keys);\n            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n            // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context, or a compact IRI.\n            if ((newContext && newContext['@version'] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')) {\n                if (parentContext && '@vocab' in parentContext && context['@vocab'].indexOf(':') < 0) {\n                    newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n                }\n                else if (Util_1.Util.isCompactIri(context['@vocab']) || context['@vocab'] in newContext) {\n                    // @vocab is a compact IRI or refers exactly to a prefix\n                    newContext['@vocab'] = newContextWrapped.expandTerm(context['@vocab'], true);\n                }\n            }\n            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase, keys);\n            // In JSON-LD 1.1, check if we are not redefining any protected keywords\n            if (!ignoreProtection && parentContext && processingMode >= 1.1) {\n                this.validateKeywordRedefinitions(parentContext, newContext, JsonLdContextNormalized_1.defaultExpandOptions, overlappingKeys);\n            }\n            if (this.validateContext && !internalOptions.skipValidation) {\n                this.validate(newContext, { processingMode });\n            }\n            return newContextWrapped;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n        }\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    async load(url) {\n        // First try to retrieve the context from cache\n        const cached = this.documentCache[url];\n        if (cached) {\n            return cached;\n        }\n        // If not in cache, load it\n        let document;\n        try {\n            document = await this.documentLoader.load(url);\n        }\n        catch (e) {\n            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n        }\n        // Validate the context\n        if (!('@context' in document)) {\n            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        return this.documentCache[url] = document['@context'];\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    async loadImportContext(importContextIri) {\n        // Load the context - and do a deep clone since we are about to mutate it\n        let importContext = await this.load(importContextIri);\n        // Require the context to be a non-array object\n        if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        // Error if the context contains another @import\n        if ('@import' in importContext) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n        importContext = Object.assign({}, importContext);\n        // Containers have to be converted into hash values the same way as for the importing context\n        // Otherwise context validation will fail for container values\n        this.containersToHash(importContext);\n        return importContext;\n    }\n}\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.ContextParser = ContextParser;\n//# sourceMappingURL=ContextParser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_CODES = exports.ErrorCoded = void 0;\n/**\n * An error that has a certain error code.\n *\n * The error code can be any string.\n * All standardized error codes are listed in {@link ERROR_CODES}.\n */\nclass ErrorCoded extends Error {\n    /* istanbul ignore next */\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorCoded = ErrorCoded;\n/**\n * All standardized JSON-LD error codes.\n * @see https://w3c.github.io/json-ld-api/#dom-jsonlderrorcode\n */\n// tslint:disable:object-literal-sort-keys\nvar ERROR_CODES;\n(function (ERROR_CODES) {\n    ERROR_CODES[\"COLLIDING_KEYWORDS\"] = \"colliding keywords\";\n    ERROR_CODES[\"CONFLICTING_INDEXES\"] = \"conflicting indexes\";\n    ERROR_CODES[\"CYCLIC_IRI_MAPPING\"] = \"cyclic IRI mapping\";\n    ERROR_CODES[\"INVALID_ID_VALUE\"] = \"invalid @id value\";\n    ERROR_CODES[\"INVALID_INDEX_VALUE\"] = \"invalid @index value\";\n    ERROR_CODES[\"INVALID_NEST_VALUE\"] = \"invalid @nest value\";\n    ERROR_CODES[\"INVALID_PREFIX_VALUE\"] = \"invalid @prefix value\";\n    ERROR_CODES[\"INVALID_PROPAGATE_VALUE\"] = \"invalid @propagate value\";\n    ERROR_CODES[\"INVALID_REVERSE_VALUE\"] = \"invalid @reverse value\";\n    ERROR_CODES[\"INVALID_IMPORT_VALUE\"] = \"invalid @import value\";\n    ERROR_CODES[\"INVALID_VERSION_VALUE\"] = \"invalid @version value\";\n    ERROR_CODES[\"INVALID_BASE_IRI\"] = \"invalid base IRI\";\n    ERROR_CODES[\"INVALID_CONTAINER_MAPPING\"] = \"invalid container mapping\";\n    ERROR_CODES[\"INVALID_CONTEXT_ENTRY\"] = \"invalid context entry\";\n    ERROR_CODES[\"INVALID_CONTEXT_NULLIFICATION\"] = \"invalid context nullification\";\n    ERROR_CODES[\"INVALID_DEFAULT_LANGUAGE\"] = \"invalid default language\";\n    ERROR_CODES[\"INVALID_INCLUDED_VALUE\"] = \"invalid @included value\";\n    ERROR_CODES[\"INVALID_IRI_MAPPING\"] = \"invalid IRI mapping\";\n    ERROR_CODES[\"INVALID_JSON_LITERAL\"] = \"invalid JSON literal\";\n    ERROR_CODES[\"INVALID_KEYWORD_ALIAS\"] = \"invalid keyword alias\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAP_VALUE\"] = \"invalid language map value\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAPPING\"] = \"invalid language mapping\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_STRING\"] = \"invalid language-tagged string\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_VALUE\"] = \"invalid language-tagged value\";\n    ERROR_CODES[\"INVALID_LOCAL_CONTEXT\"] = \"invalid local context\";\n    ERROR_CODES[\"INVALID_REMOTE_CONTEXT\"] = \"invalid remote context\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY\"] = \"invalid reverse property\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_MAP\"] = \"invalid reverse property map\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_VALUE\"] = \"invalid reverse property value\";\n    ERROR_CODES[\"INVALID_SCOPED_CONTEXT\"] = \"invalid scoped context\";\n    ERROR_CODES[\"INVALID_SCRIPT_ELEMENT\"] = \"invalid script element\";\n    ERROR_CODES[\"INVALID_SET_OR_LIST_OBJECT\"] = \"invalid set or list object\";\n    ERROR_CODES[\"INVALID_TERM_DEFINITION\"] = \"invalid term definition\";\n    ERROR_CODES[\"INVALID_TYPE_MAPPING\"] = \"invalid type mapping\";\n    ERROR_CODES[\"INVALID_TYPE_VALUE\"] = \"invalid type value\";\n    ERROR_CODES[\"INVALID_TYPED_VALUE\"] = \"invalid typed value\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT\"] = \"invalid value object\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT_VALUE\"] = \"invalid value object value\";\n    ERROR_CODES[\"INVALID_VOCAB_MAPPING\"] = \"invalid vocab mapping\";\n    ERROR_CODES[\"IRI_CONFUSED_WITH_PREFIX\"] = \"IRI confused with prefix\";\n    ERROR_CODES[\"KEYWORD_REDEFINITION\"] = \"keyword redefinition\";\n    ERROR_CODES[\"LOADING_DOCUMENT_FAILED\"] = \"loading document failed\";\n    ERROR_CODES[\"LOADING_REMOTE_CONTEXT_FAILED\"] = \"loading remote context failed\";\n    ERROR_CODES[\"MULTIPLE_CONTEXT_LINK_HEADERS\"] = \"multiple context link headers\";\n    ERROR_CODES[\"PROCESSING_MODE_CONFLICT\"] = \"processing mode conflict\";\n    ERROR_CODES[\"PROTECTED_TERM_REDEFINITION\"] = \"protected term redefinition\";\n    ERROR_CODES[\"CONTEXT_OVERFLOW\"] = \"context overflow\";\n    ERROR_CODES[\"INVALID_BASE_DIRECTION\"] = \"invalid base direction\";\n    ERROR_CODES[\"RECURSIVE_CONTEXT_INCLUSION\"] = \"recursive context inclusion\";\n    ERROR_CODES[\"INVALID_STREAMING_KEY_ORDER\"] = \"invalid streaming key order\";\n    /**\n     * JSON-LD-star\n     */\n    ERROR_CODES[\"INVALID_EMBEDDED_NODE\"] = \"invalid embedded node\";\n    ERROR_CODES[\"INVALID_ANNOTATION\"] = \"invalid annotation\";\n})(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));\n//# sourceMappingURL=ErrorCoded.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerPredicate = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst Util_1 = require(\"../Util\");\n/**\n * Interprets keys as predicates.\n * The most common case in JSON-LD processing.\n */\nclass EntryHandlerPredicate {\n    /**\n     * Handle the given predicate-object by either emitting it,\n     * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {Util} util A utility instance.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth The current depth.\n     * @param {Term} predicate The predicate.\n     * @param {Term} object The object.\n     * @param {boolean} reverse If the property is reversed.\n     * @return {Promise<void>} A promise resolving when handling is done.\n     */\n    static async handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse) {\n        const depthProperties = await util.getPropertiesDepth(keys, depth);\n        const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);\n        const depthPropertiesGraph = depth - depthOffsetGraph;\n        const subjects = parsingContext.idStack[depthProperties];\n        if (subjects) {\n            // Emit directly if the @id was already defined\n            for (const subject of subjects) {\n                // Check if we're in a @graph context\n                const atGraph = depthOffsetGraph >= 0;\n                if (atGraph) {\n                    const graphs = parsingContext.idStack[depthPropertiesGraph - 1];\n                    if (graphs) {\n                        for (const graph of graphs) {\n                            // Emit our quad if graph @id is known\n                            if (reverse) {\n                                util.validateReverseSubject(object);\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n                            }\n                            else {\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n                            }\n                        }\n                    }\n                    else {\n                        // Buffer our triple if graph @id is not known yet.\n                        if (reverse) {\n                            util.validateReverseSubject(object);\n                            parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject: object, predicate, object: subject });\n                        }\n                        else {\n                            parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1)\n                                .push({ subject, predicate, object });\n                        }\n                    }\n                }\n                else {\n                    // Emit if no @graph was applicable\n                    const graph = await util.getGraphContainerValue(keys, depthProperties);\n                    if (reverse) {\n                        util.validateReverseSubject(object);\n                        parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n                    }\n                    else {\n                        parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n                    }\n                }\n            }\n        }\n        else {\n            // Buffer until our @id becomes known, or we go up the stack\n            if (reverse) {\n                util.validateReverseSubject(object);\n            }\n            parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({ predicate, object, reverse });\n        }\n    }\n    isPropertyHandler() {\n        return true;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        const key = keys[depth];\n        if (key) {\n            const context = await parsingContext.getContext(keys);\n            if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {\n                // If this valid predicate is of type @json, mark it so in the stack so that no deeper handling of nodes occurs.\n                if (Util_1.Util.getContextValueType(context, key) === '@json') {\n                    parsingContext.jsonLiteralStack[depth + 1] = true;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return keys[depth];\n    }\n    async handle(parsingContext, util, key, keys, value, depth, testResult) {\n        const keyOriginal = keys[depth];\n        const context = await parsingContext.getContext(keys);\n        const predicate = await util.predicateToTerm(context, key);\n        if (predicate) {\n            const objects = await util.valueToTerm(context, key, value, depth, keys);\n            if (objects.length) {\n                for (let object of objects) {\n                    const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));\n                    if (value) {\n                        // Special case if our term was defined as an @list, but does not occur in an array,\n                        // In that case we just emit it as an RDF list with a single element.\n                        const listValueContainer = '@list' in Util_1.Util.getContextValueContainer(context, key);\n                        if (listValueContainer || value['@list']) {\n                            if (((listValueContainer && !Array.isArray(value) && !value['@list'])\n                                || (value['@list'] && !Array.isArray(value['@list'])))\n                                && object !== util.rdfNil) {\n                                const listPointer = util.dataFactory.blankNode();\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil, util.getDefaultGraph()));\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object, util.getDefaultGraph()));\n                                object = listPointer;\n                            }\n                            // Lists are not allowed in @reverse'd properties\n                            if (reverse && !parsingContext.allowSubjectList) {\n                                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal list value in subject position at ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n                            }\n                        }\n                    }\n                    await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse);\n                }\n            }\n        }\n    }\n}\nexports.EntryHandlerPredicate = EntryHandlerPredicate;\n//# sourceMappingURL=EntryHandlerPredicate.js.map","class DefaultGraph {\n  equals (other) {\n    return !!other && other.termType === this.termType\n  }\n}\n\nDefaultGraph.prototype.termType = 'DefaultGraph'\nDefaultGraph.prototype.value = ''\n\nmodule.exports = DefaultGraph\n","const BlankNode = require('./BlankNode.js')\nconst DefaultGraph = require('./DefaultGraph.js')\nconst fromTermRaw = require('./fromTerm.js')\nconst Literal = require('./Literal.js')\nconst NamedNode = require('./NamedNode.js')\nconst Quad = require('./Quad.js')\nconst Variable = require('./Variable.js')\n\nfunction namedNode (value) {\n  return new NamedNode(value)\n}\n\nfunction blankNode (value) {\n  return new BlankNode(value)\n}\n\nfunction literal (value, languageOrDatatype) {\n  if (typeof languageOrDatatype === 'string') {\n    if (languageOrDatatype.indexOf(':') === -1) {\n      return new Literal(value, languageOrDatatype)\n    }\n\n    return new Literal(value, null, DataFactory.namedNode(languageOrDatatype))\n  }\n\n  return new Literal(value, null, languageOrDatatype)\n}\n\nfunction variable (value) {\n  return new Variable(value)\n}\n\nfunction defaultGraph () {\n  return DataFactory.defaultGraphInstance\n}\n\nfunction triple (subject, predicate, object) {\n  return DataFactory.quad(subject, predicate, object)\n}\n\nfunction quad (subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph || DataFactory.defaultGraphInstance)\n}\n\nfunction fromTerm (original) {\n  return fromTermRaw.call(DataFactory, original)\n}\n\nfunction fromQuad (original) {\n  return fromTermRaw.call(DataFactory, original)\n}\n\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  literal,\n  variable,\n  defaultGraph,\n  triple,\n  quad,\n  fromTerm,\n  fromQuad,\n  defaultGraphInstance: new DefaultGraph()\n}\n\nmodule.exports = DataFactory\n","const DefaultGraph = require('./DefaultGraph.js')\n\nclass Quad {\n  constructor (subject, predicate, object, graph) {\n    this.subject = subject\n    this.predicate = predicate\n    this.object = object\n\n    if (graph) {\n      this.graph = graph\n    } else {\n      this.graph = new DefaultGraph()\n    }\n  }\n\n  equals (other) {\n    // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n    return !!other && (other.termType === 'Quad' || !other.termType) &&\n      other.subject.equals(this.subject) && other.predicate.equals(this.predicate) &&\n      other.object.equals(this.object) && other.graph.equals(this.graph)\n  }\n}\n\nQuad.prototype.termType = 'Quad'\nQuad.prototype.value = ''\n\nmodule.exports = Quad\n","class NamedNode {\n  constructor (iri) {\n    this.value = iri\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value\n  }\n}\n\nNamedNode.prototype.termType = 'NamedNode'\n\nmodule.exports = NamedNode\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultExpandOptions = exports.JsonLdContextNormalized = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = exports.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return ((vocab || base) ? (0, relative_to_absolute_iri_1.resolve)(vocab, base) : '') + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return (0, relative_to_absolute_iri_1.resolve)(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=JsonLdContextNormalized.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordUnknownFallback = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * A catch-all for keywords, that will either emit an error or ignore,\n * depending on whether or not the `strictValues` property is set.\n */\nclass EntryHandlerKeywordUnknownFallback {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        const key = await util.unaliasKeyword(keys[depth], keys, depth);\n        if (jsonld_context_parser_1.Util.isPotentialKeyword(key)) {\n            // Don't emit anything inside free-floating lists\n            if (!inProperty) {\n                if (key === '@list') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return jsonld_context_parser_1.Util.isPotentialKeyword(key);\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        const keywordType = EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES[key];\n        if (keywordType !== undefined) {\n            if (keywordType && typeof value !== keywordType.type) {\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid value type for '${key}' with value '${value}'`, keywordType.errorCode));\n            }\n        }\n        else if (parsingContext.strictValues) {\n            parsingContext.emitError(new Error(`Unknown keyword '${key}' with value '${value}'`));\n        }\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordUnknownFallback = EntryHandlerKeywordUnknownFallback;\nEntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES = {\n    '@index': { type: 'string', errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE },\n    '@list': null,\n    '@reverse': { type: 'object', errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_VALUE },\n    '@set': null,\n    '@value': null,\n};\n//# sourceMappingURL=EntryHandlerKeywordUnknownFallback.js.map","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  /* eslint-disable no-prototype-builtins */\n  var g =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof self !== 'undefined' && self) ||\n    // eslint-disable-next-line no-undef\n    (typeof global !== 'undefined' && global) ||\n    {};\n\n  var support = {\n    searchParams: 'URLSearchParams' in g,\n    iterable: 'Symbol' in g && 'iterator' in Symbol,\n    blob:\n      'FileReader' in g &&\n      'Blob' in g &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in g,\n    arrayBuffer: 'ArrayBuffer' in g\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n      throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        if (header.length != 2) {\n          throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)\n        }\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body._noBody) return\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);\n    var encoding = match ? match[1] : 'utf-8';\n    reader.readAsText(blob, encoding);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      /*\n        fetch-mock wraps the Response object in an ES6 Proxy to\n        provide useful test harness features such as flush. However, on\n        ES5 browsers without fetch or Proxy support pollyfills must be used;\n        the proxy-pollyfill is unable to proxy an attribute unless it exists\n        on the object before the Proxy is created. This change ensures\n        Response.bodyUsed exists on the instance, while maintaining the\n        semantic of setting Request.bodyUsed in the constructor before\n        _initBody is called.\n      */\n      // eslint-disable-next-line no-self-assign\n      this.bodyUsed = this.bodyUsed;\n      this._bodyInit = body;\n      if (!body) {\n        this._noBody = true;\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this);\n        if (isConsumed) {\n          return isConsumed\n        } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else if (support.blob) {\n        return this.blob().then(readBlobAsArrayBuffer)\n      } else {\n        throw new Error('could not read as ArrayBuffer')\n      }\n    };\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n    }\n\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal || (function () {\n      if ('AbortController' in g) {\n        var ctrl = new AbortController();\n        return ctrl.signal;\n      }\n    }());\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n\n    if (this.method === 'GET' || this.method === 'HEAD') {\n      if (options.cache === 'no-store' || options.cache === 'no-cache') {\n        // Search for a '_' parameter in the query string\n        var reParamSearch = /([?&])_=[^&]*/;\n        if (reParamSearch.test(this.url)) {\n          // If it already exists then set the value with the current time\n          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());\n        } else {\n          // Otherwise add a new '_' parameter to the end with the current time\n          var reQueryString = /\\?/;\n          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();\n        }\n      }\n    }\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n    // https://github.com/github/fetch/issues/748\n    // https://github.com/zloirock/core-js/issues/751\n    preProcessedHeaders\n      .split('\\r')\n      .map(function(header) {\n        return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n      })\n      .forEach(function(line) {\n        var parts = line.split(':');\n        var key = parts.shift().trim();\n        if (key) {\n          var value = parts.join(':').trim();\n          try {\n            headers.append(key, value);\n          } catch (error) {\n            console.warn('Response ' + error.message);\n          }\n        }\n      });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n    }\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    if (this.status < 200 || this.status > 599) {\n      throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\")\n    }\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 200, statusText: ''});\n    response.ok = false;\n    response.status = 0;\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = g.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        // This check if specifically for when a user fetches a file locally from the file system\n        // Only if the status is out of a normal range\n        if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {\n          options.status = 200;\n        } else {\n          options.status = xhr.status;\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        setTimeout(function() {\n          resolve(new Response(body, options));\n        }, 0);\n      };\n\n      xhr.onerror = function() {\n        setTimeout(function() {\n          reject(new TypeError('Network request failed'));\n        }, 0);\n      };\n\n      xhr.ontimeout = function() {\n        setTimeout(function() {\n          reject(new TypeError('Network request timed out'));\n        }, 0);\n      };\n\n      xhr.onabort = function() {\n        setTimeout(function() {\n          reject(new exports.DOMException('Aborted', 'AbortError'));\n        }, 0);\n      };\n\n      function fixUrl(url) {\n        try {\n          return url === '' && g.location.href ? g.location.href : url\n        } catch (e) {\n          return url\n        }\n      }\n\n      xhr.open(request.method, fixUrl(request.url), true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr) {\n        if (support.blob) {\n          xhr.responseType = 'blob';\n        } else if (\n          support.arrayBuffer\n        ) {\n          xhr.responseType = 'arraybuffer';\n        }\n      }\n\n      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {\n        var names = [];\n        Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n          names.push(normalizeName(name));\n          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n        });\n        request.headers.forEach(function(value, name) {\n          if (names.indexOf(name) === -1) {\n            xhr.setRequestHeader(name, value);\n          }\n        });\n      } else {\n        request.headers.forEach(function(value, name) {\n          xhr.setRequestHeader(name, value);\n        });\n      }\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!g.fetch) {\n    g.fetch = fetch;\n    g.Headers = Headers;\n    g.Request = Request;\n    g.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParsingContext = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst ErrorCoded_1 = require(\"jsonld-context-parser/lib/ErrorCoded\");\nconst ContextTree_1 = require(\"./ContextTree\");\nconst JsonLdParser_1 = require(\"./JsonLdParser\");\n/**\n * Data holder for parsing information.\n */\nclass ParsingContext {\n    constructor(options) {\n        // Initialize settings\n        this.contextParser = new jsonld_context_parser_1.ContextParser({ documentLoader: options.documentLoader, skipValidation: options.skipContextValidation });\n        this.streamingProfile = !!options.streamingProfile;\n        this.baseIRI = options.baseIRI;\n        this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;\n        this.allowSubjectList = !!options.allowSubjectList;\n        this.processingMode = options.processingMode || JsonLdParser_1.JsonLdParser.DEFAULT_PROCESSING_MODE;\n        this.strictValues = !!options.strictValues;\n        this.validateValueIndexes = !!options.validateValueIndexes;\n        this.defaultGraph = options.defaultGraph;\n        this.rdfDirection = options.rdfDirection;\n        this.normalizeLanguageTags = options.normalizeLanguageTags;\n        this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;\n        this.topLevelProperties = false;\n        this.activeProcessingMode = parseFloat(this.processingMode);\n        // Initialize stacks\n        this.processingStack = [];\n        this.processingType = [];\n        this.emittedStack = [];\n        this.idStack = [];\n        this.graphStack = [];\n        this.graphContainerTermStack = [];\n        this.listPointerStack = [];\n        this.contextTree = new ContextTree_1.ContextTree();\n        this.literalStack = [];\n        this.validationStack = [];\n        this.unaliasedKeywordCacheStack = [];\n        this.jsonLiteralStack = [];\n        this.unidentifiedValuesBuffer = [];\n        this.unidentifiedGraphsBuffer = [];\n        this.pendingContainerFlushBuffers = [];\n        this.parser = options.parser;\n        if (options.context) {\n            this.rootContext = this.parseContext(options.context);\n            this.rootContext.then((context) => this.validateContext(context));\n        }\n        else {\n            this.rootContext = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(this.baseIRI ? { '@base': this.baseIRI, '@__baseDocument': true } : {}));\n        }\n    }\n    /**\n     * Parse the given context with the configured options.\n     * @param {JsonLdContext} context A context to parse.\n     * @param {JsonLdContextNormalized} parentContext An optional parent context.\n     * @param {boolean} ignoreProtection If @protected term checks should be ignored.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.\n     */\n    async parseContext(context, parentContext, ignoreProtection) {\n        return this.contextParser.parse(context, {\n            baseIRI: this.baseIRI,\n            ignoreProtection,\n            normalizeLanguageTags: this.normalizeLanguageTags,\n            parentContext,\n            processingMode: this.activeProcessingMode,\n        });\n    }\n    /**\n     * Check if the given context is valid.\n     * If not, an error will be thrown.\n     * @param {JsonLdContextNormalized} context A context.\n     */\n    validateContext(context) {\n        const activeVersion = context.getContextRaw()['@version'];\n        if (activeVersion) {\n            if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.PROCESSING_MODE_CONFLICT);\n            }\n            else {\n                if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {\n                    throw new ErrorCoded_1.ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                }\n                this.activeProcessingMode = activeVersion;\n            }\n        }\n    }\n    /**\n     * Get the context at the given path.\n     * @param {keys} keys The path of keys to get the context at.\n     * @param {number} offset The path offset, defaults to 1.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.\n     */\n    async getContext(keys, offset = 1) {\n        const keysOriginal = keys;\n        // Ignore array keys at the end\n        while (typeof keys[keys.length - 1] === 'number') {\n            keys = keys.slice(0, keys.length - 1);\n        }\n        // Handle offset on keys\n        if (offset) {\n            keys = keys.slice(0, -offset);\n        }\n        // Determine the closest context\n        const contextData = await this.getContextPropagationAware(keys);\n        const context = contextData.context;\n        // Process property-scoped contexts (high-to-low)\n        let contextRaw = context.getContextRaw();\n        for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {\n            const key = keysOriginal[i];\n            const contextKeyEntry = contextRaw[key];\n            if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n                const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();\n                const propagate = !(key in scopedContext)\n                    || scopedContext[key]['@context']['@propagate']; // Propagation is true by default\n                if (propagate !== false || i === keysOriginal.length - 1 - offset) {\n                    contextRaw = scopedContext;\n                    // Clean up final context\n                    delete contextRaw['@propagate'];\n                    contextRaw[key] = Object.assign({}, contextRaw[key]);\n                    if ('@id' in contextKeyEntry) {\n                        contextRaw[key]['@id'] = contextKeyEntry['@id'];\n                    }\n                    delete contextRaw[key]['@context'];\n                    if (propagate !== false) {\n                        this.contextTree.setContext(keysOriginal.slice(0, i + offset), Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw)));\n                    }\n                }\n            }\n        }\n        return new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw);\n    }\n    /**\n     * Get the context at the given path.\n     * Non-propagating contexts will be skipped,\n     * unless the context at that exact depth is retrieved.\n     *\n     * This ONLY takes into account context propagation logic,\n     * so this should usually not be called directly,\n     * call {@link #getContext} instead.\n     *\n     * @param keys The path of keys to get the context at.\n     * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.\n     */\n    async getContextPropagationAware(keys) {\n        const originalDepth = keys.length;\n        let contextData = null;\n        let hasApplicablePropertyScopedContext;\n        do {\n            hasApplicablePropertyScopedContext = false;\n            if (contextData && '@__propagateFallback' in contextData.context.getContextRaw()) {\n                // If a propagation fallback context has been set,\n                // fallback to that context and retry for the same depth.\n                contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized(contextData.context.getContextRaw()['@__propagateFallback']);\n            }\n            else {\n                if (contextData) {\n                    // If we had a previous iteration, jump to the parent of context depth.\n                    // We must do this because once we get here, last context had propagation disabled,\n                    // so we check its first parent instead.\n                    keys = keys.slice(0, contextData.depth - 1);\n                }\n                contextData = await this.contextTree.getContext(keys) || { context: await this.rootContext, depth: 0 };\n            }\n            // Allow non-propagating contexts to propagate one level deeper\n            // if it defines a property-scoped context that is applicable for the current key.\n            // @see https://w3c.github.io/json-ld-api/tests/toRdf-manifest#tc012\n            const lastKey = keys[keys.length - 1];\n            if (lastKey in contextData.context.getContextRaw()) {\n                const lastKeyValue = contextData.context.getContextRaw()[lastKey];\n                if (lastKeyValue && typeof lastKeyValue === 'object' && '@context' in lastKeyValue) {\n                    hasApplicablePropertyScopedContext = true;\n                }\n            }\n        } while (contextData.depth > 0 // Root context has a special case\n            && contextData.context.getContextRaw()['@propagate'] === false // Stop loop if propagation is true\n            && contextData.depth !== originalDepth // Stop loop if requesting exact depth of non-propagating\n            && !hasApplicablePropertyScopedContext);\n        // Special case for root context that does not allow propagation.\n        // Fallback to empty context in that case.\n        if (contextData.depth === 0\n            && contextData.context.getContextRaw()['@propagate'] === false\n            && contextData.depth !== originalDepth) {\n            contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized({});\n        }\n        return contextData;\n    }\n    /**\n     * Start a new job for parsing the given value.\n     * @param {any[]} keys The stack of keys.\n     * @param value The value to parse.\n     * @param {number} depth The depth to parse at.\n     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n     * @return {Promise<void>} A promise resolving when the job is done.\n     */\n    async newOnValueJob(keys, value, depth, lastDepthCheck) {\n        await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);\n    }\n    /**\n     * Flush the pending container flush buffers\n     * @return {boolean} If any pending buffers were flushed.\n     */\n    async handlePendingContainerFlushBuffers() {\n        if (this.pendingContainerFlushBuffers.length > 0) {\n            for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {\n                await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);\n                this.parser.flushStacks(pendingFlushBuffer.depth);\n            }\n            this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Emit the given quad into the output stream.\n     * @param {number} depth The depth the quad was generated at.\n     * @param {Quad} quad A quad to emit.\n     */\n    emitQuad(depth, quad) {\n        if (depth === 1) {\n            this.topLevelProperties = true;\n        }\n        this.parser.push(quad);\n    }\n    /**\n     * Emit the given error into the output stream.\n     * @param {Error} error An error to emit.\n     */\n    emitError(error) {\n        this.parser.emit('error', error);\n    }\n    /**\n     * Emit the given context into the output stream under the 'context' event.\n     * @param {JsonLdContext} context A context to emit.\n     */\n    emitContext(context) {\n        this.parser.emit('context', context);\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.\n     * @param {number} depth A depth.\n     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n     *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.\n     */\n    getUnidentifiedValueBufferSafe(depth) {\n        let buffer = this.unidentifiedValuesBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.unidentifiedValuesBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.\n     * @param {number} depth A depth.\n     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n     *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.\n     */\n    getUnidentifiedGraphBufferSafe(depth) {\n        let buffer = this.unidentifiedGraphsBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.unidentifiedGraphsBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * @return IExpandOptions The expand options for the active processing mode.\n     */\n    getExpandOptions() {\n        return ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];\n    }\n    /**\n     * Shift the stack at the given offset to the given depth.\n     *\n     * This will override anything in the stack at `depth`,\n     * and this will remove anything at `depth + depthOffset`\n     *\n     * @param depth The target depth.\n     * @param depthOffset The origin depth, relative to `depth`.\n     */\n    shiftStack(depth, depthOffset) {\n        // Copy the id stack value up one level so that the next job can access the id.\n        const deeperIdStack = this.idStack[depth + depthOffset];\n        if (deeperIdStack) {\n            this.idStack[depth] = deeperIdStack;\n            this.emittedStack[depth] = true;\n            delete this.idStack[depth + depthOffset];\n        }\n        // Shorten key stack\n        if (this.pendingContainerFlushBuffers.length) {\n            for (const buffer of this.pendingContainerFlushBuffers) {\n                if (buffer.depth >= depth + depthOffset) {\n                    buffer.depth -= depthOffset;\n                    buffer.keys.splice(depth, depthOffset);\n                }\n            }\n        }\n        // Splice stacks\n        if (this.unidentifiedValuesBuffer[depth + depthOffset]) {\n            this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];\n            delete this.unidentifiedValuesBuffer[depth + depthOffset];\n        }\n        // TODO: also do the same for other stacks\n    }\n}\nexports.ParsingContext = ParsingContext;\nParsingContext.EXPAND_OPTIONS = {\n    1.0: {\n        allowPrefixForcing: false,\n        allowPrefixNonGenDelims: false,\n        allowVocabRelativeToBase: false,\n    },\n    1.1: {\n        allowPrefixForcing: true,\n        allowPrefixNonGenDelims: false,\n        allowVocabRelativeToBase: true,\n    },\n};\n//# sourceMappingURL=ParsingContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (options.allowPrefixNonGenDelims || (typeof value === 'string' && (value[0] === '_' || Util.isPrefixIriEndingWithGenDelim(value))));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Boolean(iri && Util.IRI_REGEX.test(iri));\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n    /**\n     * Check if two objects are deepEqual to on another.\n     * @param object1 The first object to test.\n     * @param object2 The second object to test.\n     */\n    static deepEqual(object1, object2) {\n        const objKeys1 = Object.keys(object1);\n        const objKeys2 = Object.keys(object2);\n        if (objKeys1.length !== objKeys2.length)\n            return false;\n        return objKeys1.every((key) => {\n            const value1 = object1[key];\n            const value2 = object2[key];\n            return (value1 === value2) || (value1 !== null &&\n                value2 !== null &&\n                typeof value1 === \"object\" &&\n                typeof value2 === \"object\" &&\n                this.deepEqual(value1, value2));\n        });\n    }\n    ;\n}\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@annotation': true,\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\nexports.Util = Util;\n//# sourceMappingURL=Util.js.map"],"names":["Object","defineProperty","exports","value","EntryHandlerKeyword","constructor","keyword","this","isPropertyHandler","isStackProcessor","validate","parsingContext","util","keys","depth","inProperty","test","key","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","trim","replace","hasWhitespace","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","length","every","Link","refs","parse","rel","links","type","toLowerCase","i","push","get","attr","set","link","setUnique","some","ref","has","slice","state","Error","expandRelations","end","indexOf","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","Array","isArray","toString","reduce","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","split","map","assign","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","encodedValue","Buffer","isBuffer","encodeURIComponent","item","module","ContextTree","subTrees","getContext","head","tail","subTree","subContext","then","context","setContext","removeContext","path","fromTerm","original","termType","blankNode","defaultGraph","literal","namedNode","datatype","subject","predicate","object","graph","quad","variable","Sink","ParserStream","Parser","options","super","ContainerHandlerIdentifier","canCombineWithGraph","handle","containers","id","emittedStack","idStack","keyUnaliased","getContainerKey","maybeId","resourceToTerm","dataFactory","ids","term","equals","handlePendingContainerFlushBuffers","Util","jsonld_context_parser_1","rdf_data_factory_1","EntryHandlerContainer_1","canonicalizeJson","DataFactory","rdfFirst","RDF","rdfRest","rdfNil","rdfType","rdfJson","getContextValue","contextKey","fallback","entry","getContextRaw","undefined","getContextValueContainer","getContextValueType","valueType","getContextValueLanguage","getContextValueDirection","isContextValueReverse","getContextValueIndex","isPropertyReverse","parentKey","isValidIri","iri","isPrefixArray","needle","haystack","validateValueIndexes","indexHashes","index","existingIndexValue","ErrorCoded","ERROR_CODES","CONFLICTING_INDEXES","valueToTerm","valueToJsonString","getContextSelfOrPropertyScoped","parseContext","unaliasKeywords","val","valueLanguage","valueDirection","valueIndex","subValue","JSON","stringify","INVALID_VALUE_OBJECT","unaliasKeyword","INVALID_VALUE_OBJECT_VALUE","INVALID_INDEX_VALUE","INVALID_LANGUAGE_TAGGED_VALUE","ContextParser","validateLanguage","strictValues","INVALID_LANGUAGE_TAGGED_STRING","normalizeLanguageTags","activeProcessingMode","validateDirection","rdfDirection","nullableTermToArray","createLanguageDirectionLiteral","INVALID_TYPED_VALUE","typeTerm","createVocabOrBaseTerm","JsonLdContextNormalized","INVALID_SET_OR_LIST_OBJECT","listValue","graphContainerEntries","graphContainerTermStack","values","stringValueToTerm","Boolean","XSD_BOOLEAN","XSD_INTEGER","XSD_DOUBLE","emitError","contextKeyEntry","predicateToTerm","expanded","expandTerm","getExpandOptions","produceGeneralizedRdf","substr","INVALID_IRI_MAPPING","startsWith","expandOptions","intToString","Number","isFinite","isInteger","toExponential","defaultDatatype","contextType","contextLanguage","contextDirection","direction","valueNode","getDefaultGraph","emitQuad","disableCache","cachedUnaliasedKeyword","unaliasedKeywordCacheStack","isPotentialKeyword","unliased","isValidKeyword","unaliasKeywordParent","hash","newHash","isLiteral","literalStack","jsonLiteralStack","getDepthOffsetGraph","EntryHandlerContainer","getContainerHandler","isComplexGraphContainer","validateReverseSubject","INVALID_REVERSE_PROPERTY_VALUE","getGraphContainerValue","depthContainer","graphContainerIndex","getContainerGraphIndex","graphId","getPropertiesDepth","lastValidDepth","XSD","BlankNode","nextId","other","prototype","EntryHandlerKeywordId","EntryHandlerKeyword_1","INVALID_ID_VALUE","depthProperties","listHead","COLLIDING_KEYWORDS","Impl","import","input","output","on","readable","emit","err","EntryHandlerInvalidFallback","EntryHandlerKeywordContext","streamingProfile","processingStack","processingType","INVALID_STREAMING_KEY_ORDER","parentContext","contextTree","emitContext","validateContext","resolve","relativeIRI","baseIRI","baseFragmentPos","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","buffer","colonPosition","searchOffset","pathSeparator","base","character","EntryHandlerKeywordNest","INVALID_NEST_VALUE","serialize","toJSON","t","cv","ci","comma","sort","EntryHandlerKeywordValue","unidentifiedValuesBuffer","unidentifiedGraphsBuffer","Quad","__createBinding","create","o","m","k","k2","enumerable","__exportStar","p","hasOwnProperty","call","EntryHandlerArrayValue","Util_1","listRootKey","listRootDepth","keyOption","handleListElement","newOnValueJob","shiftStack","valueOriginal","listRootKeys","listPointer","listPointerStack","newLinkTerm","linkTerm","listId","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","NamedNode","Variable","name","ContainerHandlerType","EntryHandlerPredicate_1","containerTypeType","entryHasIdentifier","keyOriginal","EntryHandlerPredicate","handlePredicateObject","Literal","stringDatatype","langStringDatatype","JsonLdParser","stream_1","EntryHandlerArrayValue_1","EntryHandlerInvalidFallback_1","EntryHandlerKeywordContext_1","EntryHandlerKeywordGraph_1","EntryHandlerKeywordId_1","EntryHandlerKeywordIncluded_1","EntryHandlerKeywordNest_1","EntryHandlerKeywordType_1","EntryHandlerKeywordUnknownFallback_1","EntryHandlerKeywordValue_1","ParsingContext_1","http_link_header_1","Transform","readableObjectMode","ParsingContext","parser","jsonParser","contextJobs","typeJobs","contextAwaitingJobs","lastDepth","lastKeys","lastOnValueJob","Promise","attachJsonParserListeners","mode","fromHttpResponse","mediaType","headers","endsWith","LOADING_DOCUMENT_FAILED","forEach","linkHeader","MULTIPLE_CONTEXT_LINK_HEADERS","ignoreMissingContextLinkHeader","contentType","match","stream","PassThrough","error","parsed","pipe","_transform","chunk","callback","write","lastDepthCheck","flushStacks","splice","isBufferableContainerHandler","pendingContainerFlushBuffers","flushBuffer","handleKey","INVALID_REVERSE_PROPERTY_MAP","validationStack","property","Math","max","validationResult","validateKey","valid","entryHandler","ENTRY_HANDLERS","testResult","graphStack","subjects","valueBuffer","depthOffsetGraph","graphs","bufferedValue","reverse","subGraphBuffer","getUnidentifiedGraphBufferSafe","graphBuffer","topLevelProperties","onValue","stack","fill","v","isParsingContextInner","valueJobCb","jobs","job","executeBufferedJobs","onError","applicableTypeJobs","applicableTypeJobIds","typeJob","sortedTypeJobs","job1","job2","sortedApplicableTypeJobIds","jobId","DEFAULT_PROCESSING_MODE","EntryHandlerKeywordIncluded","EntryHandlerKeywordGraph","EntryHandlerKeywordType","EntryHandlerKeywordUnknownFallback","C","LEFT_BRACE","RIGHT_BRACE","LEFT_BRACKET","RIGHT_BRACKET","COLON","COMMA","TRUE","FALSE","NULL","STRING","NUMBER","START","STOP","TRUE1","TRUE2","TRUE3","FALSE1","FALSE2","FALSE3","FALSE4","NULL1","NULL2","NULL3","NUMBER1","NUMBER3","STRING1","STRING2","STRING3","STRING4","STRING5","STRING6","VALUE","KEY","OBJECT","ARRAY","BACK_SLASH","charCodeAt","FORWARD_SLASH","BACKSPACE","FORM_FEED","NEWLINE","CARRIAGE_RETURN","TAB","STRING_BUFFER_SIZE","tState","string","stringBuffer","alloc","stringBufferOffset","unicode","highSurrogate","bytes_remaining","bytes_in_sequence","temp_buffs","toknam","code","l","proto","charError","String","fromCharCode","appendStringChar","char","appendStringBuf","buf","start","size","copy","n","onToken","j","byteLength","intVal","parseInt","result","isNaN","token","parseError","parent","FetchDocumentLoader","ErrorCoded_1","relative_to_absolute_iri_1","fetcher","load","url","response","fetch","Headers","accept","ok","colonPos","json","alternateUrl","statusText","status","elements","element","INVALID_TYPE_VALUE","scopedContext","hasTypedScopedContext","typeContext","c","streamingProfileAllowOutOfOrderPlainType","NamedNode_1","languageOrDatatype","RDF_LANGUAGE_STRING","XSD_STRING","ContainerHandlerLanguage","INVALID_LANGUAGE_MAP_VALUE","ContainerHandlerIdentifier_1","ContainerHandlerIndex_1","ContainerHandlerLanguage_1","ContainerHandlerType_1","isSimpleGraphContainer","checkGraphContainer","containersSelf","containersParent","graphContainer","containerHandleName","CONTAINER_HANDLERS","handler","containerName","ContainerHandlerIndex","rdf","relativeIriProtocol","termCleanup","factory","quadCleanup","cleanup","transform","objectMode","entries","prefix","destroy","INVALID_INCLUDED_VALUE","valueUnliased","indexKey","indexPropertyRaw","INVALID_TERM_DEFINITION","indexProperty","indexValues","indexValue","depthOffset","FetchDocumentLoader_1","JsonLdContextNormalized_1","documentLoader","documentCache","skipValidation","expandContentTypeToBase","remoteContextsDepthLimit","redirectSchemaOrgHttps","strictRange","errorCode","REGEX_LANGUAGE_TAG","INVALID_BASE_DIRECTION","REGEX_DIRECTION_TAG","idifyReverseTerms","expandPrefixedTerms","contextRaw","EXPAND_KEYS_BLACKLIST","isReservedInternalKeyword","keyValue","ALIAS_DOMAIN_BLACKLIST","KEYWORD_REDEFINITION","ALIAS_RANGE_BLACKLIST","getContextValueId","INVALID_KEYWORD_ALIAS","isPrefixValue","changed","canAddIdEntry","newId","expandedType","normalize","processingMode","lowercase","containersToHash","newValue","containerValue","applyScopedProtected","isTermProtected","isSimpleTermDefinitionPrefix","validateKeywordRedefinitions","contextBefore","contextAfter","deepEqual","PROTECTED_TERM_REDEFINITION","INVALID_VOCAB_MAPPING","INVALID_BASE_IRI","INVALID_DEFAULT_LANGUAGE","INVALID_VERSION_VALUE","INVALID_CONTEXT_ENTRY","INVALID_PROPAGATE_VALUE","getPrefix","CYCLIC_IRI_MAPPING","isValidIriWeak","isCompactIri","objectKey","objectValue","INVALID_TYPE_MAPPING","INVALID_REVERSE_PROPERTY","CONTAINERS_1_0","INVALID_CONTAINER_MAPPING","CONTAINERS","INVALID_LANGUAGE_MAPPING","INVALID_PREFIX_VALUE","applyBaseEntry","inheritFromParent","external","normalizeContextIri","contextIri","_a","parseInnerContexts","ignoreScopedContexts","ignoreProtection","ignoreRemoteScopedContexts","e","message","INVALID_SCOPED_CONTEXT","minimalProcessing","internalOptions","remoteContexts","CONTEXT_OVERFLOW","hasProtectedTerms","INVALID_CONTEXT_NULLIFICATION","overriddenLoad","getOverriddenLoad","parsedStringContext","contextIris","contexts","all","reducedContexts","accContextPromise","contextEntry","accContext","importContext","INVALID_IMPORT_VALUE","loadImportContext","defaultExpandOptions","newContext","overlappingKeys","newContextWrapped","INVALID_LOCAL_CONTEXT","cached","document","LOADING_REMOTE_CONTEXT_FAILED","INVALID_REMOTE_CONTEXT","RECURSIVE_CONTEXT_INCLUSION","importContextIri","depthPropertiesGraph","atGraph","getUnidentifiedValueBufferSafe","objects","listValueContainer","allowSubjectList","DefaultGraph","fromTermRaw","defaultGraphInstance","triple","fromQuad","expandVocab","contextValue","validIriMapping","vocab","vocabRelative","potentialKeyword","contextPrefixValue","allowPrefixForcing","allowVocabRelativeToBase","compactIri","shortestPrefixing","suffix","allowPrefixNonGenDelims","keywordType","VALID_KEYWORDS_TYPES","INVALID_REVERSE_VALUE","self","g","globalThis","support","searchParams","iterable","Symbol","blob","Blob","formData","arrayBuffer","isDataView","obj","DataView","isPrototypeOf","viewClasses","isArrayBufferView","ArrayBuffer","isView","normalizeName","TypeError","normalizeValue","iteratorFor","items","iterator","next","shift","done","append","header","getOwnPropertyNames","consumed","body","_noBody","bodyUsed","reject","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","view","Uint8Array","chars","bufferClone","Body","_initBody","_bodyInit","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","rejected","isConsumed","byteOffset","text","decode","oldValue","thisArg","methods","normalizeMethod","method","upcased","Request","credentials","signal","ctrl","AbortController","referrer","cache","reParamSearch","Date","getTime","reQueryString","form","bytes","parseHeaders","rawHeaders","preProcessedHeaders","line","console","warn","Response","bodyInit","RangeError","clone","redirectStatuses","redirect","location","DOMException","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","fixUrl","href","getAllResponseHeaders","responseURL","responseText","setTimeout","ontimeout","onabort","open","withCredentials","responseType","names","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","BlankNode_1","DefaultGraph_1","Literal_1","Quad_1","Variable_1","dataFactoryCounter","blankNodeCounter","blankNodePrefix","INSTANCE","resetBlankNodeCounter","ContextTree_1","JsonLdParser_1","contextParser","skipContextValidation","parseFloat","rootContext","activeVersion","PROCESSING_MODE_CONFLICT","keysOriginal","contextData","getContextPropagationAware","propagate","originalDepth","hasApplicablePropertyScopedContext","lastKey","lastKeyValue","pendingFlushBuffer","EXPAND_OPTIONS","deeperIdStack","separatorPos","charAt","isPrefixIriEndingWithGenDelim","KEYWORD_REGEX","prefixIri","ENDS_WITH_GEN_DELIM","IRI_REGEX","IRI_REGEX_WEAK","VALID_KEYWORDS","objKeys1","objKeys2","value1","value2"],"ignoreList":[],"sourceRoot":""}